#! /usr/bin/env Python'''Created on Sept. 28 2020@authors:  Jean-Luc StarckRoutines to build spherical healpix mass maps from shear measurements.shear2healpix(g1, g2, ra, dec, nside, Average=True)def wls_kaiser_squires(mg1, mg2, opt=None, Sigma=None,remove_files=True,verbose=True, Prefix="xx_wls_")def wls_sparse(mg1, mg2, covmat, Nsigma=5, Niter=10, Nscale=None, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_")def wls_wiener(mg1, mg2, covmat, Cl, Niter=100, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_")def wls_mcalens(mg1, mg2, covmat, Cl, Nsigma=5, Niter=100, Nscale=None, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_")'''import osimport numpy as np# %matplotlib inlineimport tkinterimport matplotlibmatplotlib.use('TkAgg')import matplotlib.pyplot as pltfrom astropy.io import fitsfrom PIL import Image# from lenspack.utils import bin2d# from lenspack.image.inversion import ks93# from lenspack.geometry.projections import gnomimport sys#import footprint#from footprint import draw_footprint# Set data pathimport pycs# from src.sparsity.sparse2d.mr_transform import *# from pycs.sparsity.sparse2d.starlet import *# from src.sparsity.sparse2d.wavelet import *# from src.invpb.denoising.mr_filter import *from pycs.misc.cosmostat_init import *from pycs.misc.mr_prog import *from pycs.misc.utilHSS import *from pycs.misc.stats import *from pycs.sparsity.mrs.mrs_tools import *from numpy import linalg as LAfrom sys import getsizeofimport healpy as hpdef make_healpix_map(ra, dec, weights, nside):    pixels= hp.ang2pix(nside,theta = 0.5*np.pi - np.deg2rad(dec), phi = np.deg2rad(ra))    bincount = np.bincount(pixels, minlength = hp.nside2npix(nside))    bincount_weighted = np.bincount(pixels, minlength = hp.nside2npix(nside), weights=weights)    return np.where(bincount>0.5, bincount_weighted/bincount, hp.UNSEEN)def get_bincount(ra, dec, nside):    pixels= hp.ang2pix(nside,theta = 0.5*np.pi - np.deg2rad(dec), phi = np.deg2rad(ra))    bincount = np.bincount(pixels, minlength = hp.nside2npix(nside))    return bincount##########################def shear2healpix(g1, g2, ra, dec, nside, Average=True):    """    Build a healpix from shear measurements.    For each galaxy i, g1[i], g2[i] are its shear measurements and    ra[i] and dec[i] its ra-dec coordinates.    Parameters    ----------    g1 : 1D np.ndarray        array of shears g1.    gg2 : 1D np.ndarray        array of shears g2.    ra : 1D np.ndarray        RA coordinare array.    dec : 1D np.ndarray        DEC coordinare array.    nside: int        nside parameter for the healpix map resolution.    Average: bool, optional        if True, the shear measurements for galaxoes in a given pixels are averaged. Otherwise,        only the sum is calculated.    Returns    -------    bincount : 1D np.ndarray            healpix map giving the number of galaxies per pixel.    mg1 : 1D np.ndarray        healpix map giving the shear g1 per pixel.    mg2 : 1D np.ndarray    healpix map giving the shear g2 per pixel.    """    pixels= hp.ang2pix(nside,theta = 0.5*np.pi - np.deg2rad(dec), phi = np.deg2rad(ra))    bincount = np.bincount(pixels, minlength = hp.nside2npix(nside))    mg1 = np.bincount(pixels, minlength = hp.nside2npix(nside), weights=g1)    mg2 = np.bincount(pixels, minlength = hp.nside2npix(nside), weights=g2)    if Average == True:        mg1 = np.where(bincount>0.5, mg1/bincount, 0)        mg2 = np.where(bincount>0.5, mg2/bincount, 0)    return bincount, mg1, mg2##########################def wls_kaiser_squires(mg1, mg2, opt=None, Sigma=None,remove_files=True,verbose=True, Prefix="xx_wls_"):    """    Appy the Kaiser-Squires method on spherical shear maps.    Parameters    ----------    mg1 : 1D np.ndarray        input  healpix shear g1 map.    mg2 : 1D np.ndarray        input  healpix shear g2 map.    opt : string, optional        String allowing to send more option to the called binary code.         The default is None.    Sigma : float, optional        If set, smooth the image, with a Gaussian with Sigma arcmin.         The default is None.    remove_files : bool, optional        Remove all created files on the disk. The default is True.    verbose : bool, optional        Verbose mode. The default is True.    Prefix : string, optional        "prefix used to create the temporary files". The default is "xx_wls_".    Returns    -------    ks_e : 1D np.ndarray        Kappa E-mode.    ks_b : 1D np.ndarray        Kappa B-mode.    """        prog="wls_mcalens"    # prog_path = ".../cosmostat/build/bin"    # the cosmostat binary folder has to be in the use system path    # otherwise you need to hardcode the path in the variable prog:    #     exemple: prog="Users/starck/git/cosmostat/build/bin/wls_mcalens"        # Create a unique string using the current date and time.    result=0    unique_string = datetime.now().strftime('%Y.%m.%d_%H.%M.%S')    FNin = Prefix + unique_string    FNout = Prefix + unique_string + '_out'    file1_in = FNin + '_g1.fits'    file2_in = FNin + '_g2.fits'    file1_out = FNout + '_e.fits'    file2_out = FNout + '_b.fits'    mrs_write(file1_in, mg1)    mrs_write(file2_in, mg2)    # print("PROG: ", prog)    cmd = prog    if isinstance(opt, type(None)):        optF=' '    else:        optF= opt    if verbose:        optF = optF + " -v "            cmd = cmd + " " + optF + " "  + file1_in + " "  +  file2_in + " " + FNout    if verbose:        print ('CMD = ', cmd)    args = shlex.split(cmd)    # print('args ', args)    call(args)    ks_e = mrs_read(file1_out)    ks_b = mrs_read(file2_out)    # Return the mr_transform results (and the output file names).    if remove_files:        remove(file1_in)        remove(file2_in)        remove(file1_out)        remove(file2_out)    return ks_e,ks_b##########################def wls_sparse(mg1, mg2, covmat, Nsigma=5, Niter=10, Nscale=None, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_"):    """        Appy the sparse recovery method on spherical shear maps.    Parameters    ----------    mg1 : 1D np.ndarray        input  healpix shear g1 map.    mg2 : 1D np.ndarray        input  healpix shear g2 map..    opt : string, optional        String allowing to send more option to the called binary code.         The default is None.    covmat : 1D np.ndarray        Covariance matrix.    Nsigma : float, optional        Detection level at Nsigma. The default is 5.    Niter : int, optional        Number of iterations. The default is 10.    Nscale : int, optional        Numberof scales. The default is None.    remove_files : bool, optional        Remove all created files on the disk. The default is True.    verbose : bool, optional        Verbose mode. The default is True.    Prefix : string, optional        "prefix used to create the temporary files". The default is "xx_wls_".    Returns    -------    ks_e : 1D np.ndarray        Kappa E-mode.    ks_b : 1D np.ndarray        Kappa B-mode.    """    prog="wls_mcalens -m3 "    # prog_path = ".../cosmostat/build/bin"    # the cosmostat binary folder has to be in the use system path    # otherwise you need to hardcode the path in the variable prog:    #     exemple: prog="Users/starck/git/cosmostat/build/bin/wls_mcalens"        # Create a unique string using the current date and time.    result=0    unique_string = datetime.now().strftime('%Y.%m.%d_%H.%M.%S')    FNin = Prefix + unique_string    FNout = Prefix + unique_string + '_out'    file1_in = FNin + '_g1.fits'    file2_in = FNin + '_g2.fits'    file3_in = FNin + '_covmat.fits'    file1_out = FNout + '_e.fits'    file2_out = FNout + '_b.fits'    mrs_write(file1_in, mg1)    mrs_write(file2_in, mg2)    mrs_write(file3_in, covmat)    # print("PROG: ", prog)    cmd = prog    if isinstance(opt, type(None)):        optF=' '    else:        optF= opt    if verbose:        optF = optF + " -v "    optF =  optF + " -s " + str(Nsigma) +  " -i " + str(Niter) + " "    cmd = cmd + "-N " + file3_in + " " + optF + " "  + file1_in + " "  +  file2_in + " " + FNout    if isinstance(Nscale, type(None)):        ptF =  optF  + " -n " + str(Nscale) + " "    if verbose:        print ('CMD = ', cmd)            args = shlex.split(cmd)    # print('args ', args)    call(args)    s_e = mrs_read(file1_out)    s_b = mrs_read(file2_out)    # Return the mr_transform results (and the output file names).    if remove_files:        remove(file1_in)        remove(file2_in)        remove(file3_in)        remove(file1_out)        remove(file2_out)    return s_e,s_b##########################def wls_wiener(mg1, mg2, covmat, Cl, Niter=100, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_"):    """        Appy the Wiener recovery method on spherical shear maps.        Parameters    ----------    mg1 : 1D np.ndarray        input  healpix shear g1 map.    mg2 : 1D np.ndarray        input  healpix shear g2 map..    opt : string, optional        String allowing to send more option to the called binary code.         The default is None.    covmat : 1D np.ndarray        Covariance matrix.    Cl : 1D np.ndarray        Theoretical input signal power spectrum used by the Wiener filter.    Niter : int, optional        Number of iterations. The default is 10.    remove_files : bool, optional        Remove all created files on the disk. The default is True.    verbose : bool, optional        Verbose mode. The default is True.    Prefix : string, optional        "prefix used to create the temporary files". The default is "xx_wls_".    Returns    -------    w_e : 1D np.ndarray        Kappa E-mode.    w_b : 1D np.ndarray        Kappa B-mode.    """    prog="wls_mcalens -m2 "    # prog_path = ".../cosmostat/build/bin"    # the cosmostat binary folder has to be in the use system path    # otherwise you need to hardcode the path in the variable prog:    #     exemple: prog="Users/starck/git/cosmostat/build/bin/wls_mcalens"        # Create a unique string using the current date and time.    result=0    unique_string = datetime.now().strftime('%Y.%m.%d_%H.%M.%S')    FNin = Prefix + unique_string    FNout = Prefix + unique_string + '_out'    file1_in = FNin + '_g1.fits'    file2_in = FNin + '_g2.fits'    file3_in = FNin + '_covmat.fits'    file4_in = FNin + '_cl.fits'    file1_out = FNout + '_e.fits'    file2_out = FNout + '_b.fits'    mrs_write(file1_in, mg1)    mrs_write(file2_in, mg2)    mrs_write(file3_in, covmat)    writefits(file4_in, Cl)    # print("PROG: ", prog)    cmd = prog    if isinstance(opt, type(None)):        optF=' '    else:        optF= opt    if verbose:        optF = optF + " -v "    optF =  optF  +  " -i " + str(Niter) + " "    cmd = cmd + " -N " + file3_in  + " -S " + file4_in + " " + optF + " "  + file1_in + " "  +  file2_in + " " + FNout    if verbose:        print ('CMD = ', cmd)    args = shlex.split(cmd)    # print('args ', args)    call(args)    s_e = mrs_read(file1_out)    s_b = mrs_read(file2_out)    # Return the mr_transform results (and the output file names).    if remove_files:        remove(file1_in)        remove(file2_in)        remove(file3_in)        remove(file4_in)        remove(file1_out)        remove(file2_out)    return s_e,s_b##########################def wls_mcalens(mg1, mg2, covmat, Cl, Nsigma=5, Niter=100, Nscale=None, opt=None, remove_files=True,verbose=True, Prefix="xx_wls_"):    """        Appy the MCAlens recovery method on spherical shear maps.        Parameters    ----------    mg1 : 1D np.ndarray        input  healpix shear g1 map.    mg2 : 1D np.ndarray        input  healpix shear g2 map..    opt : string, optional        String allowing to send more option to the called binary code.         The default is None.    covmat : 1D np.ndarray        Covariance matrix.    Cl : 1D np.ndarray        Theoretical input signal power spectrum used by the Wiener filter.    Niter : int, optional        Number of iterations. The default is 100.    Nsigma : float, optional        Detection level at Nsigma. The default is 5.    Nscale : int, optional        Numberof scales. The default is None.        remove_files : bool, optional        Remove all created files on the disk. The default is True.    verbose : bool, optional        Verbose mode. The default is True.    Prefix : string, optional        "prefix used to create the temporary files". The default is "xx_wls_".      Returns    -------        w_e : 1D np.ndarray        Kappa E-mode.    w_b : 1D np.ndarray        Kappa B-mode.    RES : Class        Return a class with the different fields:        in_signal_spectrum:        map_e: 1D np.ndarray, Kappa E-mode        map_b:1D np.ndarray, Kappa E-mode        map_sparse_e: 1D np.ndarray, sparse Kappa E-mode        map_sparse_b: 1D np.ndarray, sparse Kappa B-mode        map_wiener_e: 1D np.ndarray, Wiener Kappa E-mode        map_wiener_b: 1D np.ndarray, Winer Kappa B-mode        map_active_coef_e: 1D np.ndarray, active coef map  E-mode        map_active_coef_b: 1D np.ndarray, active coef map B-mode        WT_ActiveCoef_e: 2D np.ndarray, active wavelet coefficients E-mode        WT_ActiveCoef_b: 2D np.ndarray, active wavelet coefficients B-mode    """        prog="wls_mcalens -m4 "    # prog_path = ".../cosmostat/build/bin"    # the cosmostat binary folder has to be in the use system path    # otherwise you need to hardcode the path in the variable prog:    #     exemple: prog="Users/starck/git/cosmostat/build/bin/wls_mcalens"        # Create a unique string using the current date and time.    result=0    unique_string = datetime.now().strftime('%Y.%m.%d_%H.%M.%S')    FNin = Prefix + unique_string    FNout = Prefix + unique_string + '_out'    file1_in = FNin + '_g1.fits'    file2_in = FNin + '_g2.fits'    file3_in = FNin + '_covmat.fits'    file4_in = FNin + '_cl.fits'    file1_out = FNout + '_e.fits'    file2_out = FNout + '_b.fits'    file3_out = FNout + '_sparse_e.fits'    file4_out = FNout + '_sparse_b.fits'    file5_out = FNout + '_active_coef_e.fits'    file6_out = FNout + '_active_coef_b.fits'    mrs_write(file1_in, mg1)    mrs_write(file2_in, mg2)    mrs_write(file3_in, covmat)    writefits(file4_in, Cl)    # print("PROG: ", prog)    cmd = prog    if isinstance(opt, type(None)):        optF=' '    else:        optF= opt    if verbose:        optF = optF + " -v "    optF =  optF  + " -s " + str(Nsigma) + " -i " + str(Niter) + " "    cmd = cmd + " -N " + file3_in  + " -S " + file4_in + " " + optF + " "  + file1_in + " "  +  file2_in + " " + FNout    if isinstance(Nscale, type(None)):        ptF =  optF  + " -n " + str(Nscale) + " "            if verbose:        print ('CMD = ', cmd)    args = shlex.split(cmd)    # print('args ', args)    call(args)    class res_mcalens():        in_signal_spectrum=0        map_e=0        map_b=0        map_sparse_e=0        map_sparse_b=0        map_wiener_e=0        map_wiener_b=0                map_active_coef_e=0        map_active_coef_b=0        WT_ActiveCoef_e=0        WT_ActiveCoef_b=0    RES = res_mcalens()    RES.in_signal_spectrum = Cl    RES.map_e = mrs_read(file1_out)    RES.map_b = mrs_read(file2_out)    RES.map_sparse_e = mrs_read(file3_out)    RES.map_sparse_b = mrs_read(file4_out)    RES.map_wiener_e = RES.map_e - RES.map_sparse_e      RES.map_wiener_b = RES.map_b - RES.map_sparse_b      RES.WT_ActiveCoef_e = readfits(file5_out)    RES.WT_ActiveCoef_b = readfits(file6_out)       RES.map_active_coef_e = RES.WT_ActiveCoef_e.sum(0)    RES.map_active_coef_b = RES.WT_ActiveCoef_b.sum(0)    # Return the mr_transform results (and the output file names).    if remove_files:        remove(file1_in)        remove(file2_in)        remove(file3_in)        remove(file4_in)        remove(file1_out)        remove(file2_out)        remove(file3_out)        remove(file4_out)                remove(file5_out)        remove(file6_out)            return RES##########################