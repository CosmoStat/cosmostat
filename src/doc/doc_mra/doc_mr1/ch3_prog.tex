 

\chapter{\proj Image Processing Tools}
\label{ch_prog}
% \chapterhead{Programs}
\markright{Image Processing Tools}

% \section{General information}
% \textbf{IMPORTANT!} Before going any further, please read and accept the terms
% in the file COPYRIGHT.

\section{Introduction}

\subsection{License manager: cea\_lm}
\index{cea\_lm}
The directory with executables must be in the user path.  
The license manager can be run (if not already done so by your system manager)
by typing 
\begin{center}
 {\bf cea\_lm -file fileName}
 \end{center}
 or directly {\bf cea\_lm} if the default file name, {\bf cea\_lic}, is 
used. The license manager can be stopped before  by typing 
\begin{center}
 {\bf cea\_lm -kill}
 \end{center} 

For non-floating licenses, the programs
can only be executed on the computer where the  license manager is installed.\\
For floating licenses, the programs can be run from any computer (with the 
correct type of platform) on the network 
if the environment variable {\bf CEA\_LICENSE\_HOST} \index{CEA\_LICENSE\_HOST}
is set 
to the correct address (for example ariane.saclay.cea.fr), 
or if the license file is 
in the directory {\bf /usr/local/cea} 
(and {\bf  C:\verb+\+Program Files\verb+\+MR} for Windows 95/98/NT/ME, \dots).

When the license manager is running, all executables described in 
this document can be called.

\subsection{JAVA interface}
 
\subsubsection*{Required packages}
\begin{itemize}
\item JDK (http://java.sun.com/products/index.html), at least version $1.2$.
\item Swing (http://java.sun.com/products/index.html), 
at least version $1.1$. With recent JDK versions, Swing is 
included.
\item MR/1 interface Java class (mr.class, ....)
\end{itemize} 

\subsubsection*{Running the MR Java application}

On Unix computers, the {\bf CLASSPATH} variable must contain the Java class 
directory and the Swing class directory. \\ 
Run the program by typing:
\begin{verbatim}
> java mr
\end{verbatim}

On Windows, run the program by typing:
\begin{verbatim}
> jmr1
\end{verbatim}
if the default installation directory has been chosen. Otherwise you
will have to edit the jmr1.bat file, and modify the path variables according
to your installation.

% If the license manager is not running, it has to be started from the 
% menu ``System''$>$``cea\_lm...'', by selecting the ``Status'' option.


Exit the program by selecting ``Quit...'' in the ``System'' menu.
\begin{verbatim}
"System">"Quit..."
\end{verbatim}
% The license manager can be stopped before from the 
% menu ``System''$>$ ``cea\_lm...'', by selecting the ``Kill'' option.

\subsubsection*{Description}

The MR/1 graphical user interface allows the user to execute all the MR/1  
programs.
The application window contains a menu bar with 5 tear-off menus: 
\begin{itemize}
\item System: quit, and license manipulation.
\item MR/1 IMAGE: image manipulation programs (multiresolution not used).
\item MR/1 Multiresol: manipulation of multiresolution objects.
\item MR/1 Application: filtering, deconvolution, compression, detection, etc.
\item MR/1 1D: 1D programs.
\item MR/2: MR/2 programs.
\item MR/3: MR/3 programs.
\item MR/4: MR/4 programs.
\end{itemize}
To execute an MR program select the associated item (program name): \\
``MR/1 Image'' $>$ ``Manipulation tools'' $>$ ``im\_info'', 
for the im\_info program.  

The application displays a popup window. All the options of the 
program can be
selected. If a popup window is validated (by pressing the  
OK button) with an obligatory 
option not initialized, a warning dialog box prevents the user continuing.

When the dialog box is validated the program is executed. 
Information on the execution is displayed in the current window: 
\begin{verbatim}
  Program is running ...
  ... information relative to the program execution ...
  Program is finished!
The execution is now terminated.
\end{verbatim}

The help button of the dialog box displays a window with the help of the 
program.


\subsection{IDL routines}

To use IDL routines, the {\bf CEA\_MR\_DIR} \index{CEA\_MR\_DIR} variable 
must be initialized to the directory
where the MR/1-IDL software has been installed. Then 
the command
\begin{center}
{\bf idl \$CEA\_MR\_DIR/idl/pro/mre} 
\end{center}
runs the IDL session with the 
multiresolution environment. An IDL help facility on the available routines
is obtained by typing {\bf mrh} in the IDL session. 


\section{Image Format}
\index{format}
All programs read/write to raw format (.d), FITS format (.fits), 
GIF format (.gif), JPEG format (.jpg) and PGM format (.pgm). 
A raw image file name must have the 
following syntax:  FileName\_x\_Nl\_Nc.d \\
 where x defines the data type: 
\begin{verbatim}
                          x = b (byte)
                              s (short int)
                              i (int)
                              f (float)
                              d (double)
                          Nl = number of lines
                          Nc = number of columns
\end{verbatim}
 Example: ``ngc21\_f\_256\_256.d'' is a floating image (256 $\times$ 256).


A recommendation to use FITS format, wherever possible, follows.
  Noise modeling is closely
associated with high precision measurement.  Therefore the image's dynamic
range is very important. FITS supports 32 bit floating values.  
 We recommend that FITS be used for all processing in order to benefit from
the use of float values in \proj.  Images can be converted to and 
from FITS before and after use of \proj routines.  FITS is a very widely-used
image format in astronomy, and information on this standard is to be found
at various places on the Internet 
(for example, see http://heasarc.gsfc.nasa.gov/docs/software/fitsio).  
Public domain image viewers are available  
such as xv, ds9, or SAOimage, available from the 
Smithsonian Astrophysical Observatory.  Other public domain viewers, 
available on the Web, 
include FITSview from NRAO, and fv fromGSFC.  

FITS files may contain several extensions, and each extension may contain 
an image. \proj programs read only the first extension. However, the 
program {\em im\_convert} allows the user to extract an image
in a given extension, and to save it into a simple fits file, or any other
format.

When the character ``-'' is used in place of an
image file name, the standard input or
output is used. 

% This holds also when  using ``in'' and ``out'' file names.
\section{Large Image Manipulation}

All computations are carried out by default in memory. If the computer has
not
enough memory to run the program, a virtual memory mode is available
allowing the use of disk instead of memory. A temporary file is created
each time a large buffer needs to be allocated. This obviously  increases
the computation time, but allows large image manipulation (assuming enough
disk
space is available!). Virtual Memory (VM) can be activated by two options: 
``-z''
and ``-Z''. All programs working with images accept these two options. 

When a program is run with the 
``-z'' option, the virtual memory is activated using
the default parameters, which are the the minimum size buffer 
for activating the VM, and the directory where the temporary files are to
be created.
The minimum size is read from the environment variable {\bf
CEA\_VM\_SIZE} \index{CEA\_VM\_SIZE}, and
the default directory is read from the environment variable {\bf
CEA\_VM\_DIR}.
If {\bf CEA\_VM\_SIZE} and {\bf CEA\_VM\_DIR} \index{CEA\_VM\_DIR}
are not defined, the default 
 minimum size is 4 MB, and the default directory is  the current one, 
i.e.\ ``.'' (where the program is executed). 

When a program is run with the ``-Z'' option, virtual memory is activated
and the user has to specify the 
minimum size and the directory for the temporary files.

Examples:
\begin{itemize}
\item im\_info image.fits \\
gives information about an image without using the VM. The image is
loaded in memory.
\item im\_info -z image.fits \\
same, but using the VM and its default parameters.  \\
 {\bf CEA\_VM\_SIZE} and
{\bf CEA\_VM\_DIR} are read, and if the image size is larger than the
value
read from {\bf CEA\_VM\_SIZE} (or 4 MB if the environment variable
is not defined), a temporary file a created.
\item im\_info  -Z 1:/tmp image.fits \\
Same, but the VM is activated using a minimum size of only 1 MB, and
the directory for storing the temporary file is ``/tmp''. 
\end{itemize}


\newpage

\section{Image Manipulation Tools}
A number of programs have been developed for basic image manipulation.

\subsection{Image conversion: im\_convert}
\index{im\_convert}
The program {\em im\_convert} converts 
an image from one data format to another one. 
Currently supported image formats are the raw format, the FITS format, 
GIF, JPEG and PGM.  In addition the 3D FITS files used by the curvelet 
and ridgelet transforms, with extension ``.rid'' and ``.cur'', are also 
supported. 
{\bf
\begin{center}
     USAGE: im\_convert options file\_name\_in file\_name\_out
\end{center}
}
where options are:
\begin{itemize}
\item {\bf[-b]} \\
Normalize the data between 0 and 255.
\item {\bf[-x]} \\
Flip x-axis.
\item {\bf[-y]} \\
Flip y-axis.
\item {\bf[-r]} \\
90 degrees rotation.
\item {\bf[-h FitsHduNbr]} \\
FITS HDU number. FITS files may contain several extensions (or HDU), and
each extension may contain an image. This option allows the user to 
select the HDU number.
\end{itemize}
If the ``-b'' option is set, data are scaled in order to have a minimum value
equal to 0, and a maximum value equal to 255.
\subsubsection*{Examples:}
\begin{itemize}
\item im\_convert image\_f\_256\_256.d image.fits \\
Converts an image from raw format to FITS format.
\item im\_convert -b image\_f\_256\_256.d image.gif \\
Converts an image from raw format to GIF format with  normalization of scale.
\item im\_convert -h 2 image.fits  hdu2.fits \\
Extracts an image from a fits file, and save it in another fits file.
\item im\_convert -r -x image.fits  ima.fits \\
Flips first x-axis, and then rotates the image by 90 degrees, and saves 
the result in the same format.
\end{itemize}

\subsection{Image information: im\_info}
\index{im\_info}

{\em im\_info} gives information about an image:
\begin{itemize}
\baselineskip=0.4truecm
\item the number of rows and columns,
\item the minimum, the maximum,  
\item the arithmetic mean: $  {\bar x} = \frac{1}{N}\sum_k x_k$
\item the standard deviation: $\sigma = \frac{1}{N} \sum_k (x_k - {\bar x})^2 = \sqrt{{\bar {x^2}} - {\bar x}^2}$
\item the flux: $\sum_k I_k$
\item the energy: $\sum_k I_k^2$

\end{itemize}
When the ``-e'' or ``-E'' 
option is set, then the  Shannon Entropy, the Frieden Entropy and 
the Fisher information are also calculated:
\begin{itemize}
\baselineskip=0.4truecm
\item{Shannon Entropy:} The Shannon Entropy \cite{ima:shannon48} is defined as
\begin{eqnarray}
H_s(I) = - \sum_{k=1}^{N_b} p_k \log p_k
\end{eqnarray}
where $p_k$ values are derived from the histogram 
of $I$ ($p_k = {\mbox{\#}[ I_j = k]}$).  
\item{Frieden Entropy:} 
Frieden \cite{entropy:frieden75} 
entropy function is similar to Shannon's one, but the $p_k$ values 
are replaced by the normalized pixel values of the image
\begin{eqnarray}
H_f(I) = -\sum_{k=1}^N \psi_k \ln(\psi_k)
\end{eqnarray}
where $\psi_k = \frac{I_k}{\sum_k I_k}$. 
\item{Fisher information:} 
The Fisher information can be expressed by \cite{ima:frieden98,ima:hunt99}:
\begin{eqnarray}
F(I) = 4 \sum_k \nabla \left[ \sqrt{\psi_k} \right]^* 
                \nabla \left[ \sqrt{\psi_k} \right]		
\end{eqnarray}
In practice, we approximate the gradient operator, $\nabla$, with second-order
finite difference equations for each cardinal direction \cite{ima:hunt99}.
\end{itemize}
Fisher information, and Shannon Entropy in\-crea\-se when the data be\-come
more noisy or more complex, while Frieden entropy decreases. \\

When the ``-M'' option is set, then the skewness and the kurtosis
are calculated by:
\begin{eqnarray}
S  & = &  \frac{1}{N \sigma^3}\sum_k (x_k - {\bar x})^3  \nonumber \\
   & = &  \frac{1}{\sigma^3} ({\Bar {x^3}} - 3 {\bar x}{\Bar {x^2}} + 2{\bar x}^3) \\
K  & = &  \frac{1}{N \sigma^4}\sum_k (x_k - {\bar x})^4 - 3 \nonumber  \\
   & = &  \frac{1}{\sigma^4} ({\Bar {x^4}} - 4 {\bar x}{\Bar {x^3}} + 6 {\Bar {x^2}}{\bar x}^2 - 3 {\bar x}^4) - 3  
\end{eqnarray}
The skewness $S$ is zero if the data are symmetrically distributed around the mean.
If a tail extends to the right (resp. left), $S$ is positive (resp. negative).
Positive $K$ implies a higher peak and larger wings than the Gaussian 
distribution with the same mean and variance. Negative $K$ means a wider peak
and shorter wings.

The command line is:
{\bf
\begin{center}
     USAGE: im\_info file\_name\_in 
\end{center}
}
where options are:
\begin{itemize}
\item {\bf[-e]} \\
Calculates the Shannon Entropy, the Frieden Entropy and the Fisher information.
The histogram bin size value, used by for the
Shannon entropy calculation, is 1.
\item {\bf[-E HistoBinSize]} \\
Calculates the Shannon Entropy, the Frieden Entropy and the Fisher information.
The histogram bin size value, used for the
Shannon entropy calculation, is {\em HistoBinSize}.
\item {\bf[-M]} \\
Skewness and Kurtosis calculation.
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_info image\_f\_256\_256.d  \\
Gives information about the image.
\item im\_info -e image\_f\_256\_256.d \\
Ditto, but calculates also the Shannon Entropy, the Frieden Entropy and 
the Fisher information.
\end{itemize}

\subsection{Image information: im\_snr}
\index{im\_snr}
{\em im\_snr} gives the signal-to-noise ratio between two images.
Different $SNR$ measurements can be calculated.

The command line is:
{\bf
\begin{center}
     USAGE: im\_snr ReferenceImage Image
\end{center}
}
where options are:
\begin{itemize}
\item {\bf[-s SNR\_Type]} 
\begin{enumerate}
\baselineskip=0.4truecm
\item the Least Square Error: LSE (db) = $-10 log10(Variance(Error))$.
\item the Normalized LSE: NLSE (db) = $ -10 log10(Total(Error^2) / Total(Ref))$.
\item the Peak LSE: PLSE (db) = $ -10 log10(Variance(Error) / Max(Ref1^2)$.
\item the 255-Peak LSE: PLSE255(db) = $-10 log10(Variance(Error)/255^2)$.
\item The variance ratio: VRVE = Variance(Reference) / Variance(Error).
\end{enumerate}  
Default is 4.
\item {\bf[-w]} \\
Write in $SNR.fits$ the result.
\item {\bf[-v]} \\
Verbose mode. Gives all SNRs calculations.
\end{itemize}

\subsubsection*{Examples:}
\begin{itemize}
\item im\_snr image1\_f\_256\_256.d  image2\_f\_256\_256.d\\
Gives the PSNR between the two images.
\end{itemize}

\subsection{Extract a subimage: im\_get}
\index{im\_get}

{\em im\_get} extracts a part of an image:
{\bf
\begin{center}
USAGE: im\_get options image\_in image\_out
\end{center}
}
where options are:
\begin{itemize}
\item {\bf[-x Xstart:XEnd]} \\
Xstart and XEnd are the first and the last column to extract.
\item {\bf[-y Ystart:YEnd]} \\
Ystart and YEnd are the first and the last rows to extract.
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_get  -x 10:20 -y 2:5 ngc2997.fits small.fits \\
Extract a small area (lines 2 to 5, and columns 10 to 20) from the
image ngc2997.fits.
\item im\_get -x 10:20 -y 2:5 ngc2997.fits - $\mid$ im\_info - \\
Same as before, but send the extracted image to the standard output and
pipe it to {\em im\_info}. A sample result is:
\begin{verbatim}
File name = -
 
  Nl = 4  Nc = 11
  Min = 219  Max = 352
  Mean = 301.341  sigma = 28.5673
  Flux = 13259  Energy = 4.03139e+06
\end{verbatim}
\end{itemize}

\subsection{Insert a subimage: im\_put}
\index{im\_put}

{\em im\_put} inserts an image into a larger one:
{\bf
\begin{center}
USAGE: im\_put options image\_in  image\_inout
\end{center}
}
where options are:
\begin{itemize}
\item {\bf[-x Xstart]} \\
x-coordinate of the image to insert.
\item {\bf[-y Ystart]} \\
y-coordinate of the image to insert.
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_put  -x 10 -y 2 small.fits ngc2997.fits \\
Insert a small image at position (10,2) in ngc2997.fits. 
\end{itemize}

\subsection{Operation on two images: im\_op}
\index{im\_op}

{\em im\_op} calculates an operation on two images.
{\bf
\begin{center}
USAGE: im\_put image\_in1 $[+-*/]$ image\_in2 image\_out
\end{center}}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_op  image1.d - image2.d  image\_out.d\\
image\_out.d is equal to image1.d - image2.d.
\item im\_op  image1.d / image2.d  image\_out.d\\
image\_out.d is equal to image1.d / image2.d.
\item im\_op  image1.d $\backslash *$  image2.d  image\_out.d\\
image\_out.d is equal to image1.d * image2.d. The ``$\backslash$'' 
character is
added in order to avoid the shell interpreting the ``*'' character.

\end{itemize}

\subsection{Create a noise map: im\_random}
\index{im\_random}
{\em im\_random} creates a noisy image.
{\bf
\begin{center}
USAGE: im\_random options image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-x Nc]} \\
 Number of columns. Default is 256.
\item {\bf[-y Nl]} \\
Number of lines. Default is 256.
\item {\bf [-t DistribLaw]}  
\begin{enumerate}
\baselineskip=0.4truecm
\item Gaussian.
\item Poisson.
\item Rayleigh.
\item Laplace.
\end{enumerate}
Type of distribution used for the noise creation. Default is Gaussian.
\item {\bf [-s DistribParam]} \\
Distribution parameter. Default is 1.
\item {\bf [-I InitRandomVal]} \\
Value used for random value generator initialization. \\
Default is 100. 
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_random  -t 1 -s 10 image\_out.d  \\
image\_out.d contains Gaussian noise, with a noise standard 
deviation equal to 1.
\item im\_random  -t 2 -s 1 image\_out.d  \\
image\_out.d contains Poisson noise, with a mean value equal to 1.
\end{itemize}

\subsection{Image simulation: im\_simu}
\index{im\_simu}

{\em im\_simu} adds noise (Poisson, Gaussian, or both kinds of noise)
to the input image, and/or convolves it beforehand with a 
point spread function (PSF)
which can either be read from a file, or created by the program.
If the PSF is simulated, it is a Gaussian and a parameter fixes the
full-width at half-maximum (FWHM). 
{\bf
\begin{center}
USAGE: im\_simu options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-p ]} \\
Add Poisson Noise. Default is not to do this.
\item{\bf [-g sigma]} \\
Add Gaussian noise. {\em sigma} is the standard 
deviation of the added noise. Default is not to do this.
\item{\bf [-c sigma]} \\
Add Poisson noise and Gaussian noise. 
{\em sigma} is standard deviation of the Gaussian noise. Default is not to do this.
\item{\bf [-r psf\_image]} \\
Convolve the input image with a PSF. The 
PSF is read from a file of name {\em psf\_image}. Default is not to do this.
 \item{\bf [-f FWHM]} \\
Convolve the input image with a PSF. The PSF
is a Gaussian which has a full-width at half-maximum equal 
to {\em FWHM}. Default is not to do this.
\item {\bf [-I InitRandomVal]} \\
Value used for random value generator initialization. \\
Default is 100. 
\item{\bf [-w PsfFileName]} \\
Write the calculated PSF to  disk. \\
 Valid only if ``-f'' option is set.
Default is not to do this.
\end{itemize}

The r and f options cannot be used together. \\
The g, p, and c options cannot be used together. \\
\subsubsection*{Examples:}
\begin{itemize}
\item im\_simu -g 200 image.d image\_g200.d \\
Add Gaussian noise to an image.
\item im\_simu -f 3. -g 200 image.d image\_g200.d \\
Convolve the image with a Gaussian (FWHM=3), and add Gaussian noise of
standard deviation equal to 200.
\item im\_simu -r PSF.d -c 20 image.d image\_g200.d \\
Convolve the image with another one (PSF.d), and add Poisson
noise and read-out noise (Gaussian noise).
\end{itemize}

\subsection{Image segmentation: im\_segment}
\index{im\_segment}

The program 
{\em im\_segment} applies a segmentation to the input image. The 
image is first thresholded.
{\bf 
\begin{center}
USAGE: im\_segment options Threshold image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-b ]} \\Eliminates regions at the border. Default is no elimination.
\end{itemize}


\subsection{Image mirror extension: im\_mirror}
\index{im\_mirror}

The program {\em im\_mirror} extends an image by interpolating the image borders
by mirror effect. $N_x,N_y$ are the number of rows and columns, the
output image $O$ is defined by $O(x,y) = I(x_1,y_1)$, where
$I$ is the input image,
 $x_1 = M(x, N_x)$, $x_1 = M(y, N_y)$, and  $M$ is defined by
\begin{eqnarray*}
M(k,N) & = & \left\{  \begin{array}{ccc}
   k & {\rm if } & k \in [0,N-1] \\
   -k & {\rm if } & k < 0 \\
   2(N-1)-k & {\rm if } & k \ge N 
\end{array}\right. 
\end{eqnarray*}
The size of the output image can be fixed by the ``-x'' and ``-y'' options.
If neither of these options is set, the size is chosen to the smallest
power of two larger than $N_x$ and $N_y$. \\

The command line is:
{\bf
\begin{center}
USAGE: im\_mirror options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-x  Number\_of\_Columns]} \\
Number of columns of the output image. By default, it takes the next 
power of 2.
\item {\bf[-y  Number\_of\_Lines]} \\
Number of rows of the output image. By default, it takes the next 
power of 2.
\end{itemize}
\subsubsection*{Example:}
\begin{itemize}
\item im\_mirror -x 256 -y 256 image\_in.d image\_out\_256.d \\
Extend an image by mirror effect in order to get a new square image of
size 256.
\end{itemize}

\subsection{Image thresholding: im\_threshold}
\index{im\_threshold}

The program {\em im\_threshold} thresholds an image. 
{\bf
\begin{center}
USAGE: im\_threshold options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-t ThresholdMin]} \\
Threshold all values lower than ThresholdMin. All pixels with a value
lower than  {\em ThresholdMin} are set to 0.
Default is 0 (negative values are thresholded).
\item {\bf[-t ThresholdMax]} \\
 Set to ThresholdMax  all values larger than ThresholdMax.
 Default is no.
\item {\bf[-a]} \\
Compare the absolute value to the threshold. Default is no.
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item im\_threshold  image\_in.d image\_out.d \\
Threshold all negative values in the data.
\item im\_threshold  -t 10 image\_in.d image\_out.d \\
All pixels with values smaller than 10 are set to 0.
\item im\_threshold  -t 10 -a image\_in.d image\_out.d \\
All pixels with absolute values smaller than 10 are set to 0.
\item im\_threshold  -T 255 image\_in.d image\_out.d \\
All pixels with values larger than 255 are set to 255.
\end{itemize}

\subsection{Image rotation: im\_rot}
\index{im\_rot}
\index{rotation}

The program {\em im\_mirror} rotates an image by a given angle.
Translation may also be done if needed. 
The rotation operator is given by:
\begin{eqnarray}
R(\theta) = 
\left[\begin{array}{cc}
               \cos \theta &  - \sin \theta  \\
               \sin \theta  & \cos \theta   
       \end{array}
\right]   
\end{eqnarray}
A bilinear interpolation method is used by default by the program.

It has been shown \cite{ima:danielsson92,ima:unser95} that the 
whole transformation can be decomposed into an
appropriate sequence of 1D signal translations that can all be implemented
via simple convolutions using the following factorization:
\begin{eqnarray}
R(\theta)   & = &
\left[\begin{array}{cc}
               \cos \theta &  - \sin \theta  \\
               \sin \theta  & \cos \theta   
       \end{array}
\right]  = \left[\begin{array}{cc}
               1 &  - \tan \frac{\theta}{2} \\
               0  & 1   
       \end{array}
\right]  \nonumber \\  
  &  &  X \left[\begin{array}{cc}
               1 &  0 \\
                \sin \theta  & 1   
       \end{array}
\right]
 X \left[\begin{array}{cc}
               1 &  -\tan \frac{\theta}{2} \\
               0  & 1   
       \end{array}
\right]
\end{eqnarray}

The command line is:
{
\bf
\begin{center}
USAGE: im\_rot options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-r RotAngle]} \\
Rotation angle in degrees.
\item {\bf[-x  Dx]} \\
x-axis translation offset.
\item {\bf[-y  Dy]} \\
y-axis translation offset.
\item {\bf[-f]} \\
Use the factorization in order to have a reversible transformation.
(Since the Fourier transform is used, the image size must be a power of 2.)
\end{itemize}
\subsubsection{Examples:}
\begin{itemize}
\item im\_rot -r 30 image\_in.d image\_out.d \\
Rotate an image by 30 degrees.
\item im\_rot -x 5 -r 30 image\_in.d image\_out.d \\
Rotate an image by 30 degrees, but first shift the image by five pixels
along the x-axis.
\end{itemize}

\newpage
\section{Fourier analysis}
\index{fourier}
\index{fft}
\subsection{Introduction}
The Fourier transform of a continuous function $f(x)$ is defined by:
\begin{eqnarray}
\hat{f}(\nu) = \int_{-\infty}^{+\infty} f(x) \exp\{-i 2\pi \nu x\}
\end{eqnarray}
and the inverse Fourier transform is:
\begin{eqnarray}
f(x) = \int_{-\infty}^{+\infty}  \hat{f}(\nu) \exp\{i 2\pi \nu x\}
\end{eqnarray}
The discrete Fourier transform is given by:
\begin{eqnarray}
\hat{f}(u) = \frac{1}{N} \sum_{k=-\infty}^{+\infty} f(k) \exp\{-i 2\pi u k\}
\end{eqnarray}
and the inverse discrete Fourier transform is:
\begin{eqnarray}
\hat{f}(k) =  \sum_{u=-\infty}^{+\infty} f(u) \exp\{i 2\pi u k\}
\end{eqnarray}

In the case of images (two variables), this is:
\begin{eqnarray}
\hat{f}(u,v) & = & \frac{1}{MN} \sum_{l=-\infty}^{+\infty}
\sum_{k=-\infty}^{+\infty} f(k,l) \exp\{-2i\pi (\frac{u k}{M} + \frac{vl}{N} )\} \\
f(k,l) & = &  \sum_{u=-\infty}^{+\infty}
\sum_{v=-\infty}^{+\infty} \hat{f}(u,v) \exp\{2i \pi (\frac{u k}{M} + \frac{vl}{N} )\}
\end{eqnarray}

Since $\hat{f}(u,v)$ is generally complex, it can be written using its
real and imaginary parts:
\begin{eqnarray}
\hat{f}(u,v) = Re[\hat{f}(u,v)] + i Im[\hat{f}(u,v)]
\end{eqnarray}
with:
\begin{eqnarray}
Re[\hat{f}(u,v)] & = & \frac{1}{MN} \sum_{l=-\infty}^{+\infty}
\sum_{k=-\infty}^{+\infty} f(k,l)   \cos(2\pi (\frac{u k}{M} + \frac{vl}{N} ))  \\
Im[\hat{f}(u,v)] & = & - \frac{1}{MN} \sum_{l=-\infty}^{+\infty}
\sum_{k=-\infty}^{+\infty} f(k,l)  \sin(2\pi (\frac{u k}{M} + \frac{vl}{N} ))  \\
\end{eqnarray}
It can also be written using its modulus and argument:
\begin{eqnarray}
\hat{f}(u,v) = \  \mid \hat{f}(u,v) \mid  \exp\{ i \arg{\hat{f}(u,v)}\}
\end{eqnarray}
$\mid \hat{f}(u,v) \mid^2$ is called power spectrum, and 
$\Theta(u,v) = \arg{\hat{f}(u,v)}$ the phase.

Two other related transforms are the cosine and the sine transform.
The discrete cosine transform is defined by:
\begin{eqnarray*}
DCT(u,v) & = &  \frac{1}{\sqrt{2N}} c(u)c(v)
\sum_{k=0}^{N-1} \sum_{l=0}^{N-1} f(k,l) 
              \cos(\frac{(2k+1)u\pi}{2N})  \cos(\frac{(2l+1)v\pi }{2N}) \nonumber \\
IDCT(k,l) & = & \frac{1}{\sqrt{2N}}  
\sum_{u=0}^{N-1}\sum_{v=0}^{N-1} c(u)c(v) DCT(u,v) 
              \cos(\frac{(2k+1)u\pi}{2N})  \cos(\frac{(2l+1)v\pi }{2N})
\end{eqnarray*}
with $c(i) = \frac{1}{\sqrt{2}} $ when $i = 0$ and $1$ otherwise.


\subsection{Fourier transform (float): fft\_f\_2d}
\index{fft\_f\_2d}

The program 
{\em fft\_f\_2d} computes the Fourier transform. Only FITS format is supported
by FFT routines. The output file name must not have any suffix. The program
adds ``\_re.fits'' to the output file name for the real part of the Fourier 
transform, and ``\_im.fits'' for the imaginary part.  
{\bf
\begin{center}
USAGE: fft\_f\_2d options  image\_in  image\_out  
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-r ]} \\
Apply an inverse Fourier transform. 
Default is not to do this.
\item {\bf[-s ]} \\
 Zero frequency is by default in the middle of the image.
 If the ``s'' option is set, zero frequency is at the bottom left.
\end{itemize}
The input image
must be an integer or a floating image, and the output image is a
complex one.
\subsubsection*{Examples:}
 \begin{itemize}
\item  fft\_f\_2d imag.fits cf\_imag \\
Computes the Fourier transform of imag.fits.
\item  im\_info cf\_imag\_re.fits \\
Print information about the real part of the Fourier transform.
\item  im\_info cf\_imag\_im.fits \\
Print information about the imaginary part of the Fourier transform.
\end{itemize}

\subsection{Fourier transform (complex): fft\_cf\_2d}
\index{fft\_cf\_2d}
The program 
{\em fft\_cf\_2d} computes the Fourier transform.
{\bf
\begin{center}
USAGE: fft\_cf\_2d  options image\_in  image\_out  
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-r ]} \\
Apply an inverse Fourier transform. Then the input and output
 images are complex. \\
Default is not to do this.
\item {\bf[-s ]} \\
 Zero frequency is by default in the middle of the image.
 If the ``s''  option is set, zero frequency is at the bottom left.
\end{itemize}
\subsubsection*{Examples:}
\begin{itemize}
\item  fft\_cf\_2d imag  inv\_imag \\
Computes the inverse Fourier transform of imag.fits 
(see previous section).
\item  im\_info inv\_imag\_re.fits \\
Prints information about the real part of the inverse Fourier transform.
\item  im\_info cf\_imag\_im.fits \\
Prints information about the imaginary part of the inverse Fourier transform.
\end{itemize}

\subsection{Cosine transform: im\_dct}
\index{im\_dct}
The program 
{\em im\_dct} computes the cosine transform of an N $\times$ N 
image, where $N$ is a
power of 2.
{\bf
\begin{center}
USAGE: im\_dct  options image\_in  image\_out  
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-r ]} \\
Apply an inverse cosine transform. \\
Default is not to do this.
\end{itemize}
\subsubsection*{Example:}
\begin{itemize}
\item  im\_dct imag.fits dct\_imag \\
Computes the cosine transform of imag.fits.
\end{itemize}

\subsection{Sinus transform: im\_dst}
\index{im\_dst}

The program 
{\em im\_dst} computes the sine transform of an N $\times$ 
N image, where $N$ is a power of 2.
{\bf
\begin{center}
USAGE: im\_dst  options image\_in  image\_out  
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-r ]} \\
Apply an inverse sine transform. \\
Default is no.
\end{itemize}
\subsubsection*{Example:}
\begin{itemize}
\item  im\_dst imag.fits dst\_imag \\
Computes the sine transform of imag.fits.
\end{itemize}
\newpage

\section{Mathematical morphology}
\index{mathematical morphology}
\subsection{Introduction}
Originally developed by Matheron \cite{ima:matheron67,ima:matheron75}
and Serra \cite{ima:serra82}, mathematical morphology is based 
on two operators: the {\em infimum} (denoted $\mmin$) 
and the {\em supremum}  (denoted $\mmax$). 
The infimum of a set of images is defined
as the greatest lower bound while the {\em supremum} is defined as 
the least upper bound. The basic morphological transformations 
are erosion, dilation, opening and closing. For gray-level images, 
they can be defined in the following way:
\begin{itemize}

\item {\it dilation} consists of  
replacing each pixel of an image by the maximum of its neighbors.
\[
\delta_B(f) = \bmmax_{b \in B} f_b
%  = \max\{f(x-k) + b(k) \}  \forall k \in B
\]
where $f$ stands for the image, and $B$ denotes the
structuring element, typically a small convex set such a square or disk.

The dilation is commonly known
as ``fill", ``expand", or ``grow." It can be used to fill ``holes" of a 
size equal to or smaller than the structuring element.
Used with binary images, where each pixel is either 1 or 0, dilation is
similar to convolution. Over each pixel of the image, the origin of 
the structuring element is overlaid. If the image pixel is nonzero,
 each pixel of the structuring element is added to the result using 
 the ``or" operator.

\item {\it erosion} consists of 
replacing each pixel of an image by the minimum of
its neighbors:
\[
\epsilon_B(f) = \bmmin_{b \in B} f_{-b}
% = \min\{f(x-k) - b(k) \}  \forall k \in B
\]
where $f$ stands for the image, and $B$ denotes the structuring element.

Erosion is the dual of dilation. It does to the background what dilation 
does to the foreground. This operator is commonly known as ``shrink" 
or ``reduce".
 It can be used to remove islands smaller than the structuring element. 
Over each pixel of the image, the origin of the structuring 
element is overlaid. If each nonzero element of the 
structuring element is contained in the image, the output pixel is set to one. 

\item {\it opening} consists of doing an erosion followed by a dilations.
\[
\alpha_B = \delta_B \epsilon_B \mbox{ and }  \alpha_B(f) = f \circ B
\]
\item {\it closing} consists of doing a dilation followed by an erosion.
\[
\beta_B = \epsilon_B \delta_B  \mbox{ and }  \beta_B(f) = f  \bullet B
\]
\end{itemize}
In a more general way, {\em opening} and {\em closing} refer to morphological
filters which respect some specific properties \cite{ima:breen00}.

The skeleton of an object in an image is a set of lines that reflect the
shape of the object. The set of skeletal pixels can be considered to
be the medial axis of the object. More details can be found in \cite{ima:soille99}. 
   
\subsection{Erosion: im\_erode}
\index{im\_erode}
\index{erosion}
\label{sect_erode}
The {\em im\_erode} program implements the erosion operator on grayscale
images.   
{\bf
\begin{center}
USAGE: im\_erode options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-n erosion\_number]} \\
Number of times the erosion is repeated. Default 
is 1.
\item{\bf [-s structural\_element ]} \\
Type of structuring element:
\begin{enumerate}
\baselineskip=0.4truecm
\item square
\item cross
\item circle
\end{enumerate}
Default is 3.
\item{\bf [-d Dim]}  \\
  Dimension of the structuring element. Only used for 
square and circle structuring 
  elements. Default is 3.
\end{itemize}
\subsubsection*{Example:}
\begin{itemize}
\item  im\_erode imag.fits erode\_imag \\
Computes the erosion transform of imag.fits.
\end{itemize}
 
\subsection{Dilation: im\_dilate}
\index{im\_dilate}
\index{dilation}
The {\em im\_dilate} program implements the dilation operator on grayscale
images by the structuring element.  
{\bf
\begin{center}
USAGE: im\_dilate options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-n dilation\_number]}  
\item{\bf [-s structural\_element ]} 
\item{\bf [-d Dim]}   
\end{itemize}
See \ref{sect_erode} for description of options.
\subsubsection*{Example:}
\begin{itemize}
\item  im\_dilate imag.fits dilate\_imag \\
Computes the dilation transform of imag.fits.
\end{itemize}

\subsection{Opening: im\_opening}
\index{im\_opening}
The {\em im\_opening} program implements the 
opening (erosion followed by a dilation)
 operator on grayscale images.
{\bf
\begin{center}
USAGE: im\_opening options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-n opening\_number]}  
\item{\bf [-s structural\_element ]} 
\item{\bf [-d Dim]}   
\end{itemize}
See \ref{sect_erode} for description of options.
\subsubsection*{Example:}
\begin{itemize}
\item  im\_opening imag.fits opening\_imag \\
Computes the opening transform of imag.fits.
\end{itemize}

\subsection{Closing: im\_closing}
\index{im\_closing}
\index{closing}
The {\em im\_closing} program implements the 
closing (dilation followed by an erosion)
 operator on grayscale images.
{\bf
\begin{center}
USAGE: im\_closing options image\_in image\_out
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-n closing\_number]}  
\item{\bf [-s structural\_element ]} 
\item{\bf [-d Dim]}   
\end{itemize}
See \ref{sect_erode} for description of options.
\subsubsection*{Example:}
\begin{itemize}
\item  im\_closing imag.fits closing\_imag \\
Computes the closing transform of imag.fits.
\end{itemize}

\subsection{Morphological skeleton: im\_thin}
\index{im\_thin}
\index{skeleton}
The {\em im\_thin} program returns the ``skeleton" of a bi-level image. 
The result is a byte type image in which skeletal pixels are set to 1
and all other pixels are zero.
{\bf
\begin{center}
USAGE: im\_thin options Threshold image\_in image\_out
\end{center}}
All values lower than {\em Threshold} are set to zero, and values higher are
set to 1. The skeleton is calculated on this bi-level image.
\subsubsection*{Example:}
\begin{itemize}
\item  im\_thin 50 imag.fits skel\_imag \\
Computes the  skeleton of imag.fits.
\end{itemize}

\newpage
\section{Principal component analysis}
\index{Principal component analysis}
\subsection{Introduction}
Principal component analysis (PCA), also often referred to as the 
eigenvector, Hotelling, 
or Karhunen-Lo\`eve transform \cite{ima:karhunen47,ima:loeve48,ima:hotelling33}
allows us to transform  discrete signals into a sequence of uncorrelated 
coefficients. Considering a population $D(1..M,1..N)$ 
of $M$ signals or images of dimension $N$,
the PCA method  expresses the data set $D$ by:
\begin{eqnarray}
D = U \Lambda^{\frac{1}{2}} V^t
\end{eqnarray}
and
\begin{eqnarray}
DD^t & = & U \Lambda U^t \\
D^t D & = & V \Lambda V^t
\end{eqnarray}
where $\Lambda$ is the diagonal matrix of eigenvalues of the covariance 
matrix $C = DD^t$, the columns of $U$ are the eigenvectors of $DD^t$, and 
the columns of $V$ contain the eigenvectors of $D^t D$. 

For a signal $d(1..N)$ we have,
\begin{eqnarray}
d = \sum_{i=1}^{M} \sqrt{\lambda_i} u_i v_i^t
\end{eqnarray}
where $\lambda_i$ are the eigenvalues of the covariance matrix and where
$u_i$ and $v_i$ are the ith columns of $U$ and $V$. The $v_i$
vectors can also be calculated by \cite{ima:bijaoui79}:
 \begin{eqnarray}
 V(i,j) = v_i(j) = \frac{1}{\sqrt{\lambda_i}} \sum_k D(i,k) u_i(j)
\end{eqnarray}

In practice, we construct the matrix $A$ whose rows are formed 
from the eigenvectors
of $C$ \cite{ima:gonzalez93}, ordered by 
decreasing order of associated eigenvalues. 
A vector $x(1..M)$ can then be
transformed by:
\begin{eqnarray}
y = \Lambda^{-\frac{1}{2}}A(x-m_x)
\end{eqnarray}
where $m_x$ is the mean value of $x$.
Because the rows of $A$ are orthonormal vectors, $A^{-1} = A^t$, 
any vector $x$ can be recovered from its corresponding $y$ by:
\begin{eqnarray}
x = \Lambda^{\frac{1}{2}}A^t y + m_x
\end{eqnarray}

The $\Lambda$ matrix multiplication can be seen as a normalization.
Building $A$ from the correlation matrix instead of the covariance matrix
leads to another kind of normalization, 
and the $\Lambda$ matrix can be suppressed 
($y = A(x-m_x)$ and $x = A^t y + m_x$). Then the norm of $y$ will be equal to the
norm of $x$.  

\subsection{Transform: im\_pca}
\index{im\_pca}
The {\em im\_pca} program applies a PCA to a series of images, and prints 
the correlation matrix, its eigenvalues, and its eigenvectors. If the 
``-w'' option is set, the eigenvector images are written to disk.
{\bf 
\begin{center}
USAGE: im\_pca options image\_list
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-w]}  \\
Write to  disk the eigenvector images. \\
File names are: pca\_x \\
where x is the eigenvector number.
\item{\bf [-M]} \\
 Do not subtract the mean.
\end{itemize}
\subsubsection{Examples:}
\begin{itemize}
\item  im\_pca -w imag1.fits imag2.fits imag3.fits imag4.fits\\
Print the correlation matrix, and the eigenvalues. Write to 
disk the following files (eigenvectors): \\
pca\_1.fits, pca\_2.fits, pca\_3.fits, pca\_4.fits.
\item  im\_pca -M -w imag1.fits imag2.fits imag3.fits imag4.fits\\ \\
Ditto, but do not subtract the mean before calculating the correlation matrix.
\end{itemize}


\subsection{Transform: im\_pca\_rec}
\index{im\_pca\_rec}
The command
{\em im\_pca\_rec} carries out the same operations as {\em im\_pca}, and
performs a reconstruction from a subset of eigenvectors. 
{\bf
\begin{center}
USAGE: im\_pca\_rec options image\_list output\_prefix\_file\_name
\end{center}}
where options are:
\begin{itemize}
\item {\bf[-w]}  \\
Write to disk the eigenvector images. \\
File names are: pca\_x \\
where x is the eigenvector number.
\item{\bf [-M]} \\
 Do not subtract the mean.
\item{\bf [-F NbrEigenVect]} \\
Number of (largest) eigenvectors used for the reconstruction. \\
Default is set to the number of images ($\Longrightarrow$ output = input).
\item{\bf [-K EigenVect\_Number]} \\
Eigenvector number which will not be used for the reconstruction.
\end{itemize}
\subsubsection{Examples:}
\begin{itemize}
\item  im\_pca\_rec -F 1 imag1.fits imag2.fits imag3.fits imag4.fits imaout\\
Apply the PCA on the four images, and reconstruct the four images from
only the first eigenvector. The four reconstructed image  names are
imaout\_1.fits, imaout\_2.fits, imaout\_3.fits, and imaout\_4.fits.
\item  im\_pca\_rec -K 2 -K 3 imag1.fits imag2.fits imag3.fits imag4.fits imaout \\
Omit eigenvectors 2 and 3 in the reconstruction.
\end{itemize}

