
\chapter{\projmr3 \ Multi-Channel Data Set}
\index{multi-channel}
\section{Introduction}

Modern image processing applications often involve multispectral data.
This can be color images in R, G and B coordinates, observations of the same 
area but at different times, etc. Much effort in the compression application
domain
has been expended in recent years in order to compress efficiently such
data sets. The challenge is to have a data representation which takes
into account at the same time both the spatial and the spectral 
(or temporal) correlation. A three-dimensional transform-based coding
technique has been proposed in \cite{mc:saghri95}, consisting of
a one-dimensional spectral Karhunen-Lo\`eve transform 
\cite{ima:karhunen47} (KLT)
and a two-dimensional spatial discrete cosine transform (DCT).
The KLT is used to decorrelate the spectral domain and the 
DCT is used to decorrelate the spatial domain.
All images are first decomposed into blocks, and each block uses its own
Karhunen-Lo\`eve transform instead of one single transform 
for the whole image.
Lee \cite{mc:lee99} has improved on this approach by introducing a varying
block size. The block size is defined using a quadtree, followed by 
bit allocation
for each block. The DCT transform can also be replaced by a wavelet 
transform \cite{mc:epstein92,mc:tretter95} (WT). 

We present in this chapter how a Wavelet-KLT transform can be used for
noise removal. Decorrelating first the data in the spatial domain using 
the WT and following that in the 
spectral domain, by the KLT, has the advantage of
providing us with robust noise modeling in the WT-KLT space, and hence to
be able 
to filter the transformed data in an efficient and effective 
way. We show also that
the correlation matrix can be computed by different methods based on  
the noise modeling. These methods are evaluated with a set of different 
images. 
 
We first present the Wavelet-KLT transform and how to model the 
noise in this space. We then describe three different methods to 
filter the coefficients, and finally illustrate these approaches with
 a set of experiments.

% We are interested in having an entropy measurement 
% of such data sets, knowing that the correlation between two images 
% can be relatively high. A 3-dimensional wavelet transform is not 
% appropriate because the third dimension is generally completely different
% from the two first. The standard case is the data set where we have 
% 2-dimensional spatial information versus a frequency band.
 

\section{The Wavelet-Karhunen-Lo\`eve transform}
\subsection{Definition}
The Karhunen-Lo\`eve transform, also often referred to as eigenvector,
Hotelling transform, or Principal Component Analysis (PCA)
 \cite {ima:karhunen47,ima:loeve48,ima:hotelling33}
allows us to transform  discrete signals into a sequence of uncorrelated 
coefficients.
Considering a vector $D={d_1,..., d_L}$   
of $L$ signals or images  of dimension N 
(i.e., $N$ pixels per image), 
we denote $M = \left\{m_1, ..., m_L\right\}$ the 
mean vector of the population ($m_i$ is the mean of the ith
signal $d_i$). The covariance matrix $C$ of $D$ is defined by 
$C = (D-M)(D-M)^t$, and is of order $L \times L$. 
Each element $c_{i,i}$ of $C$ is
the variance of $d_i$, and each element $c_{i,j}$ is the 
covariance between $d_i$ and
$d_j$. The KLT method consists of 
applying the following transform to all
vectors $x_i = \left\{d_1(i),...,d_L(i)\right\}$ ($i=1..N$):
\begin{eqnarray}
y_i = \Lambda^{-\frac{1}{2}}A(x_i-M)
\label{eqn_trans}
\end{eqnarray}
where $\Lambda$ is the diagonal matrix of eigenvalues of the covariance 
matrix $C$, and $A$ is a matrix whose rows are formed 
from the eigenvectors
of $C$ \cite{ima:gonzalez93}, ordered following  
decreasing order of eigenvalues. 

Because the rows of $A$ are orthonormal vectors, $A^{-1} = A^t$, and
any vector $x_i$ can be recovered from its corresponding $y_i$ by:
\begin{eqnarray}
x_i = \Lambda^{\frac{1}{2}}A^t y_i + M
\end{eqnarray}

The $\Lambda$ matrix multiplication can be seen as a normalization.
Building $A$ from the correlation matrix instead of the covariance matrix
leads to another kind of normalization, 
and the $\Lambda$ matrix can be suppressed 
($y_i = A(x_i-M)$ and $x_i = A^t y_i + M$). Then the norm of $y$ will 
be equal to the norm of $x$.  

\begin{figure}[htb]
\centerline{
\vbox{
\hbox{ 
\psfig{figure=fig_wtpca.ps,bbllx=1cm,bblly=11cm,bburx=19cm,bbury=27cm,width=12cm,height=10cm,clip=}
}
}}
\caption{WT-KLT transform flowchart. Each frame of the input data set is first wavelet
transformed, and a principal component analysis is applied at each resolution
level.}
\label{fig_wtpca}
\end{figure}

We suppose now that we have $L$ observations of the same view, e.g.\
at different wavelengths (or at different epochs, etc.), and denote 
as $d_l$ one 
observation, $W^{(l)}$ its wavelet transform, and $w_{l,j,k}$ one wavelet
coefficient at scale $j$ and at position $k$. 
The standard approach would be to use an orthogonal wavelet transform, and
to calculate the correlation matrix $C$ from the wavelet coefficients instead
of the pixel values:
\begin{eqnarray}
C_{m,n} =  
 \frac{\sum_{j=1}^{J} \sum_{k=1}^{N_j} w_{m,j,k} w_{n,j,k}}
                      {\sqrt{\sum_{j=1}^{J} \sum_{k=1}^{N_j} w^2_{m,j,k}} \sqrt{\sum_{j=1}^{J} \sum_{k=1}^{N_j} w^2_{n,j,k}}}
\label{Correlation_matrix1}
\end{eqnarray}
where $J$ is the number of bands, and $N_j$ is the number of coefficients
in the band $j$.
In \cite{mc:lee99}, a more complex approach has been
proposed, which  is to decompose the images into $N_b$ blocks and 
apply a KLT o each block separately.  
We investigate here different approaches for data restoration.


\subsection{Correlation matrix and noise modeling}
We introduce a noise model into our calculation of the correlation matrix.
Indeed, if the input sequence $D$ contains noise, then the 
wavelet coefficient 
are noisy too. Eigenvalues at the high scales are computed with 
noisy WT coefficients and 
we may lose the true underlying  correlation that exists 
between the input images $d_l$.
The expression of the correlation matrix has to be modified in order 
to allow us to take into account the noise.
We add a weighting term to each wavelet coefficient  which 
depends on the signal to noise ratio.
The correlation matrix is calculated by:
\begin{eqnarray}
C_{m,n} =
 {\frac{ \sum_{j=1}^{J} \sum_{k=1}^{N_j}  p_j(w_{m,j,k}) w_{m,j,k} p_j(w_{n,j,k}) w_{n,j,k}}
                      {\sqrt{  \sum_{j=1}^{J} \sum_{k=1}^{N_j}  p^2_j(w_{m,j,k}) w^2_{m,j,k}} \sqrt{\sum_{j=1}^{J} \sum_{k=1}^{N_j} p^2_j(w_{n,j,k}) w^2_{n,j,k}}}}
\label{Correlation_matrix2}
\end{eqnarray}
where $p_j$ is a weighting function. The standard approach corresponds to the 
specific case where $p_j(w_m) = 1$ (no weighting). By considering that only
wavelet coefficients with high signal to noise ratio should be used for 
the correlation matrix calculation, $p_j$ can be defined by:
\begin{eqnarray}
p_j(w) = \left\{
  \begin{array}{ll}
  \mbox{ 1 } & \mbox{ if }  w \mbox{ is significant} \\
  \mbox{ 0 } & \mbox{ if }  w \mbox{ is not significant}
  \end{array}
  \right.
\end{eqnarray}
and a wavelet coefficient $w$ is said to be ``significant'' 
if its probability of being 
due to noise is smaller than a given $\epsilon$ value. In the case of
Gaussian noise, it suffices to compare  the wavelet coefficients $w$ to
a threshold level $t_j$. $t_j$ is generally taken as $\lambda \sigma_j$, where
$\sigma_j$ is the noise standard deviation at scale $j$, and $\lambda$ is 
chosen
between 3 and 5. The value of $\lambda=3$ corresponds to a probability of 
false
detection of $0.27$\%, for Gaussian statistics.

This hard weighting scheme may lead to problems if only a few coefficient are 
significant, and can be replaced by a soft weighting one, by
defining $p_j(w)$ by:
\begin{eqnarray}
p_j(w) =  1 - \mathrm{Prob}(W > \mid w \mid)   
\end{eqnarray}
where $\mathrm{Prob}(W > \mid w \mid)$ is the probability that a wavelet
coefficient is larger than $w$ due to the noise. For Gaussian noise, we have:
\begin{eqnarray}
   p_j(w)  & =  & 1 - \frac{2}{\sqrt{2 \pi} 
\sigma_j} \int_{\mid w  \mid}^{+\infty} \exp(-W^2/2\sigma^2_j) dW \nonumber \\ 
 & = & \mbox{erf}(\frac{\mid w  \mid }{\sqrt{2}\sigma_j})
\end{eqnarray}

\subsection{Scale and Karhunen-Lo\`eve transform}

We can also analyze separately each band of the 
wavelet transform, and then apply one KLT per resolution level. This 
implies calculating a correlation matrix $C^{(j)}$ for each band $j$.

\begin{eqnarray}
C^{(j)}_{m,n} =   
 {\frac{\sum_{k=1}^{N_j} p_j(w_{m,j,k}) w_{m,j,k} p_j(w_{n,j,k}) w_{n,j,k}}
                      {\sqrt{\sum_{k=1}^{N_j}  p^2_j(w_{m,j,k}) w^2_{m,j,k}}  \sqrt{\sum_{k=1}^{N_j} p^2_j(w_{n,j,k}) w^2_{n,j,k}}}}
\label{Correlation_matrix3}
\end{eqnarray}

This has the advantage to take into account more complex behavior of the
signal. Indeed, structures of different sizes may have a different 
spectral behavior (for example, stars and galaxies in astronomical images),
and a band-by-band independent analysis allows us to better represent
this kind of data.


\subsection{The WT-KLT transform}
The final WT-KLT algorithm has these steps:
\begin{enumerate}
\item Estimate the noise standard deviation $\sigma^{(l)}$ of each input
data set $d_l$.
\item Calculate the wavelet transform $W^{(l)}$ of its each input
data set $d_l$.
\item For each band $j$ of the wavelet transform, calculate
the correlation matrix $C^{(j)}$ relative to the vector 
$x_j = \left\{ W^{(1)}_j, W^{(2)}_j, ..., W^{(L)}_j \right\}$, where 
$W^{(l)}_j$ represents the band $j$ of the wavelet transform $W^{(l)}$ of $d_l$.
\item For each band $j$, we diagonalize the matrix $C^{(j)}$ and build the
transform matrix $A_j$ from the eigenvectors of $C^{(j)}$.
\item For each band $j$ and each position $k$, we apply the matrix $A_j$
to the vector
$x_{j,k} = \left\{ w_{1,j,k}, w_{2,j,k}, ..., w_{L,j,k} \right\}$:
\begin{eqnarray}
  y_{j,k} = A_j x_{j,k}
\end{eqnarray}
\item The WT-KLT coefficients $c_{l,j,k}$ are derived from $y_{j,k}$ by
$c_{l,j,k} = y_{j,k}(l)$. The $l$ index in the transformed coefficients
no longer represent the observation number, but instead the 
eigenvector number.
$l=1$ indicates the main eigenvector while $l=L$  indicates  the last one.
\end{enumerate}
The mean vector $M$ disappears in this algorithm because the wavelet 
coefficients are zero mean.

Figre~\ref{fig_wtpca} shows the flowchart of the WT-KLT transform.


\subsection{The WT-KLT reconstruction algorithms}
 
The reconstruction algorithm has these steps:
\begin{enumerate}
\item For each band $j$ and each position $k$, we apply the matrix $A_j^t$
to the vector 
$y_{j,k} = \left\{ c_{1,j,k}, c_{2,j,k}, ..., c_{L,j,k} \right\}$
\begin{eqnarray}
  x_{j,k} = A_j^t y_{j,k}
\end{eqnarray}
\item The wavelet coefficients $w_{l,j,k}$ are derived from $x_{j,k}$ by
 $ w_{l,j,k} = x_{j,k}(l)$.
\item An inverse wavelet transform of $W^{(l)}$ furnishes $d_l$.   
\end{enumerate}




\subsection{WT-KLT Transform of 1D Multichannel Data: wk1d\_trans}
\index{wk1d\_trans}
\label{sect_mc1d_trans}
The program 
{\em wk1d\_trans} computes the WT-KLT  transform of 
a multichannel 1D signal (2D data set). 
The wavelet transform (\`a trous algorithm)
is applied on each individual 1D signal, and the KL transform is applied for
each resolution level, exept the last (smooth) scale. 
So we have a set of eigenvectors for 
each resolution level $j$ $\{e_{j,1}, \dots, e_{j,N}\}$.
The output is a set 
$N$ multiresolution transform files in FITS format (suffix ``.fits''). 
Eigenvectors
are stored by increasing importance. The ith multiresolution file 
($i = 1 \dots N$)
contains the eigenvectors $\{e_{1,i}, \dots, e_{J-1,i}\}$, where $J$ is the 
maximum resolution level (last smooth array).
{\bf
\begin{center}
 USAGE: wk1d\_trans option data\_in prefix\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
 \item {\bf [-n number\_of\_scales]} \\
 Number of scales used in the multiresolution transform.
 Default is 4.
\item {\bf [-C]} \\
Write the correlation matrix to disk. 
The file name is ``Correl\_Matrix''. Default is not to do this.
\item {\bf [-x CorrelMat\_Method]}
{\small
\begin{itemize}             
\item{0:} One correlation matrix per band. 
\item{1:} One correlation matrix for all bands. 
\item{2:} One correlation matrix for all band, except the last scale. 
\item{3:} Import correlation matrix.
\end{itemize}
Default is one correlation matrix per band.
}             
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
Input correlation matrix file name.
Only used when option ``-x 3'' is set. Default is not to avail of this.
\end{itemize}

\subsubsection*{Examples}
\begin{itemize}
\item wk1d\_trans input.fits wk \\
Calculate the WT-KLT of the input data and store the eigenvectors
in the files ``wk\_ev\_1.fits, ..., wk\_ev\_N.fits''. Each file number $i$ 
contains a 2D data set. A given row $j$  represents eigenvector 
number $i$ at resolution level $j$. 
\item wk1d\_trans -C input.fits wk \\
Ditto, but write the calculated correlation matrix to disk.
\end{itemize}

\subsection{WT-KLT Reconstruction of 1D Multichannel Data: wk1d\_trec}
\index{wk1d\_trec}
The program 
{\em wk1d\_trec} computes the WT-KLT  transform of 
a multichannel 1D signal (2D data set), and reconstructs the data from
a subset of eigenvectors. By default, only the first eigenvector is
used at each resolution level.
{\bf
\begin{center}
 USAGE: wk1d\_trec option data\_in data\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item {\bf [-n number\_of\_scales]} \\
 Number of scales used in the multiresolution transform.
 Default is 4.
\item {\bf [-C]} \\
Write the correlation matrix to disk. 
The file name is ``Correl\_Matrix''. Default is not to do this.
\item {\bf [-x CorrelMat\_Method]}
{\small
\begin{itemize}   
\baselineskip=0.4truecm
\itemsep=0.1truecm          
\item{0:} One correlation matrix per band. 
\item{1:} One correlation matrix for all bands. 
\item{2:} One correlation matrix for all band, except the last scale. 
\item{3:} Import correlation matrix.
\end{itemize}
Default is one correlation matrix per band.
}             
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
Input correlation matrix file name.
Only used when option ``-x 3'' is set. Default is not to use this. 
\item {\bf [-F NbrEigenVect]} \\
Number of eigenvectors used for the reconstruction. 
Default is set to the number of images.
\item {\bf [-K EigenVect\_Number]} \\
Eigenvector number which will not be used for the reconstruction. 
\end{itemize}
\subsubsection*{Examples}
\begin{itemize}
\item wk1d\_trec input.fits output.fits \\
Computes the WT-KLT  transform and reconstructs the data from
the first eigenvector of each resolution level.
\item wk1d\_trec -F 3  input.fits output.fits \\
Use the three first eigenvectors
\item wk1d\_trec -F 7 -K 2 -K 3 -K 4 trans.fits output.fits \\
Use four eigenvectors (i.e., eigenvectors 1,5,6,7).
\end{itemize}


\subsection{WT-KLT Transform of 2D Multichannel Data: wk\_trans}
\index{wk\_trans}
\label{sect_mc_trans}
The program 
{\em wk\_trans} computes the WT-KLT  transform of 
a multichannel image (3D data set) containing $N$ frames 
($N < 500$). The wavelet transform
is applied to each frame, and the KL transform is applied to each
resolution level, exept the last (smooth) scale. 
So we have a set of eigenvectors for 
each resolution level $j$ $\{e_{j,1}, \dots, e_{j,N}\}$.
The output is a set 
$N$ multiresolution transform files (suffice ``.mr''). Eigenvectors
are stored by increasing importance. The ith multiresolution file (i=1..N)
contains the eigenvectors $\{e_{1,i}, \dots, e_{J-1,i}\}$, where $J$ is the 
maximum resolution level (last smooth array).
If the output file name
given by the user does not contain the ``.mr'' suffix, it is automatically
added. The ``.mr'' file is a FITS format file, and can be manipulated by
any package dealing with FITS format.
{\bf
\begin{center}
 USAGE: wk\_trans option image\_in wtklt\_transform\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\item {\bf [-t type\_of\_multiresolution\_transform]}
\itemsep=0.1truecm
{\small 
\begin{enumerate}
\baselineskip=0.4truecm
\item linear wavelet transform: \`a trous algorithm 
\item B-spline wavelet transform: \`a trous algorithm 
\item wavelet transform in Fourier space 
\item morphological median transform 
\item morphological minmax transform 
\item pyramidal linear wavelet transform 
\item pyramidal B-spline wavelet transform 
\item pyramidal wavelet transform in Fourier space: 
                     wavelet =  between two resolutions 
\item  pyramidal wavelet transform in Fourier space: 
                     wavelet = difference between the square of two resolutions
\item  pyramidal median transform 
\item  pyramidal Laplacian 
\item  morphological pyramidal minmax transform 
\item  decomposition on scaling function 
\item  (bi-) orthogonal wavelet transform. \\ 
Antonini 7/9 filters ~\cite{wave:antonini92} are used by default, with an 
$L_1$ normalization. The filters can be changed using the ``-T'' option, and
an $L_2$ normalization is obtained by ``-L'' option.
\item  Feauveau wavelet transform 
\item  Feauveau wavelet transform without undersampling 
\item  G transform (non-redundant morphological min-max algorithm)
\item Haar wavelet transform (L2 normalization).
\item Half-pyramidal wavelet transform (HPWT)
\item Mixed HPWT and Median method
\item dyadic wavelet transform 
\item Mixed WT and PMT method (WT-PMT) 
\item Undecimated Haar transform: \`a trous algorithm
\item Undecimated (bi-) orthogonal wavelet transform. \\
Antonini 7/9 filters ~\cite{wave:antonini92} are used by default, with an 
$L_1$ normalization. The filters can be changed using the ``-T'' option, and
an $L_2$ normalization is obtained by ``-L'' option.
\end{enumerate}}
Default is 2.
\item {\bf [-T type\_of\_filters]}  
{\small
\begin{enumerate}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item Antonini 7/9 filters. 
\item Daubechies filter 4. 
\item Biorthogonal 2/6 Haar filters.
\item Biorthogonal 2/10 Haar filters.
\item Odegard 7/9 filters.
\item User's filters.
\end{enumerate}}
Default is Antonini 7/9 filters. \\
 This option is only available if the chosen transform method is
 the (bi-) orthogonal transform (-t 14 or -t 24).
\item {\bf [-L]} \\
Use an $L_2$ normalization. Default is $L_1$.
% \item {\bf [-u]} \\
% Number of undecimated scales used in the Undecimated Wavelet Transform
% Default is all scales.
 \item {\bf [-n number\_of\_scales]} \\
 Number of scales used in the multiresolution transform.
 Default is 4.
\item {\bf [-C]} \\
Write the correlation matrix to disk. 
The file name is ``Correl\_Matrix''. Default is not to do this.
% \item {\bf [-p]} \\
% Normalize the correlation matrix. Values on the diagonal are 1. 
% Default is no.
\item {\bf [-x CorrelMat\_Method]}
{\small
\begin{itemize}      
\baselineskip=0.4truecm
\itemsep=0.1truecm       
\item{0:} One correlation matrix per band. 
\item{1:} One correlation matrix for all bands. 
\item{2:} One correlation matrix for all band, except the last scale. 
\item{3:} Import correlation matrix.
\end{itemize}
Default is one correlation matrix per band.
}             
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
Input correlation matrix file name.
Only used when option ``-x 3'' is set. Default is not to do this.
\end{itemize}

\subsubsection*{Examples}
\begin{itemize}
\item wk\_trans cube.fits wk \\
Calculate the WK-KLT of a 3D data set. If the cube contains $N$ frames,
$N$ files will be created (wk\_ev\_1.mr, ..., wk\_ev\_N.mr).
\item mr\_extract -b 2 wk\_ev\_1.mr b2\_1  \\
Extract the second band from the multiresolution file ``wk\_ev\_1.mr''.
The file ``b2\_1.fits'' contains an image which
corresponds to the first eigenvector at the second resolution level.
\end{itemize}


\subsection{WT-KLT Reconstruction of 2D Multichannel Data: wk\_trec}
\index{wk\_trec}
The program 
{\em wk\_trec} computes the WT-KLT  transform of 
a multichannel image (3D data set), and reconstructs the data from
a subset of eigenvectors.
The output file contains the reconstruction. Most of the options are the
same as those described in section~\ref{sect_mc_trans}.
{\bf
\begin{center}
 USAGE: wk\_trans option image\_in wtklt\_transform\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\itemsep=0.1truecm

\item {\bf [-t type\_of\_multiresolution\_transform]} \\
see section~\ref{sect_mc_trans}.
\item {\bf [-T type\_of\_filters]}  
see section~\ref{sect_mc_trans}.
\item {\bf [-L]} 
see section~\ref{sect_mc_trans}.
\item {\bf [-n number\_of\_scales]}
\item {\bf [-w]} \\
 Write to  disk the eigenvectors multiresolution files.
File names are: ``wk\_ev\_x.mr'',  where x is the eigenvector number.
Default is not to do this.
\item {\bf [-C]}
Write the correlation matrix to disk. 
The file name is ``Correl\_Matrix''. Default is not to do this.
\item {\bf [-x]} 
{\small
\begin{itemize}       
\baselineskip=0.4truecm
\itemsep=0.1truecm      
\item{0:} One correlation matrix per band. 
\item{1:} One correlation matrix for all bands. 
\item{2:} One correlation matrix for all band, except the last scale. 
\item{3:} Import correlation matrix.
\end{itemize}
Default is one correlation matrix per band.
}             
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
Input correlation matrix file name.
Only used when option ``-x 3'' is set. Default is not to do this.
\item {\bf [-F NbrEigenVect]} \\
Number of eigenvectors used for the reconstruction. 
Default is set to the number of images.
\item {\bf [-K EigenVect\_Number]} \\
Eigenvector number which will not be used for the reconstruction. 
\end{itemize}

\subsubsection*{Examples}
\begin{itemize}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item wk\_trec in\_cube.fits out\_cube \\
Calculate the WT-KLT transform, and reconstruct only from the 
first eigenvector of each scale.
\item wk\_trec -F 5 in\_cube.fits out\_cube  \\
Calculate the WT-KLT transform, and reconstruct from the 
first five eigenvectors of each scale.
\item wk\_trec -F 5 -K 2 in\_cube.fits out\_cube  \\
Ditto, but do not use eigenvector number 2. Only 4 eigenvectors are
used.
\item wk\_trec -F 5 -K 2 -t24  trans.fits output.fits \\
Ditto, but use the undecimated wavelet transform instead of the 
\`a trous algorithm.
\item wk\_trec -F 5 -K 1 -K 3 -t24  trans.fits output.fits \\
Only three eigenvectors (i.e., eigenvectors numbered 2,4,5) are used. 
\end{itemize}


\section{Noise Modeling in the WT-KLT Space}
Since a WT-KLT coefficient $c$ is obtained by two successive linear 
transforms, robust noise modeling can be derived in order to know 
 the noise standard deviation associated with the $c$ value.

\subsection{Non-Gaussian noise}
If the noise in the data $D$ is Poisson, the Anscombe transformation 
\cite{rest:anscombe48}
\begin{eqnarray}
t(D) = 2\sqrt{D + \frac{3}{8}}
\end{eqnarray}
acts as if the data arose from a
Gaussian white noise model, with $\sigma = 1$, under the
assumption that the mean value of $I$ is sufficiently large.
The arrival of photons, and their expression by electron counts, on CCD
detectors may be modeled by a Poisson distribution.  In addition, there is 
additive Gaussian read-out noise. The Anscombe 
transformation has been extended to take this combined noise into 
account.  The  generalization of the variance stabilizing
Anscombe formula is derived as \cite{starck:book98}:
\begin{eqnarray}
t(D) = \frac{2}{g} \sqrt{g D + \frac{3}{8} g^2 + \sigma^2 - g m}
\end{eqnarray}
where $g$ is the electronic gain of the detector, $\sigma$ and $m$ the standard deviation 
and the mean of the read-out noise. 
 
This implies that for the filtering of an image with Poisson noise or
a mixture of Poisson and Gaussian noise, we will first pre-transform 
the data $D$ into another one $t(D)$ with Gaussian noise. Then $t(D)$ 
will be filtered, and the filtered data will be inverse-transformed.

For other kinds of noise, modeling must be performed in order to 
define the noise probability distribution of the wavelet coefficients 
\cite{starck:book98}.   
In the following, we will consider only stationary Gaussian noise.

\subsection{Noise level on WT-KLT coefficients}
Assuming a Gaussian noise standard deviation $\sigma_l$ for each signal 
or image $d_l$, the noise in the wavelet space follows a Gaussian distribution
$\sigma_{l,j}$, $j$ being the scale index. For a bi-orthogonal wavelet 
transform with a $L^2$ normalization, $\sigma_{l,j} = \sigma_{l}$ for all $j$.
Since the WT-KLT coefficients are obtained from a linear transform, we can
easily derive the noise standard deviation relative to a WT-KLT coefficient
from the noise standard deviation relative to the wavelet coefficients.
Considering the noise standard deviation vector  
$s = \left\{\sigma_{1}, ..., \sigma_{L} \right\}$, we apply the
following transformation:
\begin{eqnarray}
y_j = A_j^2 s^2
\end{eqnarray}
and the noise standard deviation relative to a WT-KLT coefficient 
$ c_{l}(j,k)$ is $\sqrt{y_j(l)}$. 



\section{Multichannel Data Filtering}
\index{filtering}
\subsection{Introduction}
KLT based filtering methods have been proposed 
in the past \cite{mc:andrews76,mc:lee91,mc:constant97} for single images.
The proposed idea was to decompose the image $I$ of $M \times N$ pixels
into non-overlapping blocks $B_s$ of size $N_b \times N_b$. Typically, $N_b$ takes
values from 4 to 16. Let $\lambda_1,\lambda_2,...\lambda_n$ be the 
singular values of the matrix $I$ in decreasing order, and
assuming that the matrix $I$ is noisy, the rank $r$ of $I$ 
has been defined as \cite{mc:constant88}
\begin{eqnarray}
\lambda_r \ge \epsilon_1 > \lambda_{r+1}
\end{eqnarray}
where $\epsilon_1$ is the norm of the noise. In case of 
a Gaussian distribution of zero mean, an upper bound is $\sqrt{MN}\sigma$
\cite{mc:constant97}.
A filtered version of $I$ can be obtained by reconstructing each block
only from its $r$ first eigenvalues.
An original approach has been developed in \cite{mc:natarajan95,mc:constant97}
in order to find the optimal
$\epsilon$ value, based on the $\epsilon$-compression ratio curve, using 
a lossless compression method like JPEG. It has been found that the maximum 
of the second derivative of the curve furnishes the 
optimal $\epsilon$ value \cite{mc:natarajan95}.

In the case of multichannel data filtering, several different approaches 
may be considered based on noise modeling. They are 
presented in this section, and evaluated in the next one.

\subsection{Reconstruction from a subset of eigenvectors}
The WT-KLT transform of a data set $D=\left\{d_1, ..., d_L\right\}$
consists of applying a KLT on the wavelet scales. Hence the vector
$W_j = \left\{ W_j^{(1)}, ..., W_j^{(L)}\right\}$ of the scales 
$j$ of the wavelet
transforms $W^{l}$ can be decomposed uniquely as:
\begin{eqnarray}
 W_j = U_j \Lambda_j^{1 \over 2}  V_j^{-1} = \sum_{i=1}^L 
 \sqrt{\lambda_{j,i}}  {u}_{j,i} 
 {v}_{j,i}^t
\end{eqnarray}
where $\Lambda_j$ is the diagonal matrix of eigenvalues of the correlation
matrix $C_j$,  $U_j$ and $V_j$ are orthogonal matrices with column vectors
$u_{j,i}$ and $v_{j,i}$ which are respectively 
 the eigenvectors of $W_j W_j^t$ and $W_j^t W_j$.

% \overrightarrow{u}_{j,i}
The filtered wavelet coefficients of the band $j$ can be obtained by:
\begin{eqnarray}
\tilde W_j =  \sum_{i=1}^r \sqrt{\lambda_{j,i}}  {u}_{j,i} {v}_{j,i}^t
\end{eqnarray}
where $r$ is the rank of the matrix.


\subsection{WT-KLT Coefficient Thresholding}
Hard thresholding can  be applied to the  WT-KLT coefficients
in a fashion analogous to the thresholding of wavelet coefficients.

\subsubsection*{Example: astronomical source detection}

Figure~\ref{fig_exp_trans1} shows a simulation. We created
a dataset of 18 frames, each of them containing a source (i.e., a point
source, or idealized star) at the 
same position, 
but at different intensity levels. The source is a small Gaussian, and 
the source SNR is defined as the ratio between the maximum of the source and 
the noise standard deviation. Figure~\ref{fig_exp_trans1} (top) shows the
evolution of the SNR in the 18 frames. Frames two and ten 
are shown in Figure~\ref{fig_exp_trans1}, middle 
left and right. The source 
SNR ratio is respectively three and one. Figure~\ref{fig_exp_trans1}, bottom
left and right, shows respectively frame ten filtered by the 
 wavelet transform and the WT-KLT. The WT detects only noise, while the 
WT-KLT clearly identifies the source.

\begin{figure}[htb]
\centerline{
\vbox{
\hbox{ 
\psfig{figure=transp1.ps,bbllx=0.1cm,bblly=18cm,bburx=11cm,bbury=25cm,width=8cm,height=5.2cm,clip=}
}
\hbox{ 
\psfig{figure=transp1.ps,bbllx=0.5cm,bblly=1cm,bburx=22cm,bbury=18cm,width=13.6cm,height=11.2cm,clip=}
}
}}
\caption{Simulation: the dataset is composed of 18 frames. 
Each of them contains a source (small Gaussian) at the same position, 
but at different intensity levels. Top, plot of the source maximum value versus
the frame number. Middle, frames 2 and 10, and bottom, filtered version
of the frame 10 by the wavelet transform and wavelet Karhunen-Lo\`eve transform.}
\label{fig_exp_trans1}
\end{figure}


\subsection{Multiscale Entropy}
The multiscale entropy relative to a set of observations $D(1..M)$ can 
be written as:
\begin{eqnarray}
H(D) = \sum_{l=1}^{L} \sum_{j=1}^{J}  \sum_{k=1}^{N_j} h(c_{l,j,k})
\end{eqnarray}
where $J$ is the number of scales used in the wavelet transform
decomposition, $L$ the number of observations, $k$ a pixel position,
 $c$ WT-PCA coefficients, and $l$ denotes the eigenvector number.

The last scale of the wavelet transform is not used, as previously, so
this entropy measurement is background independent, which is really
important because the background can vary from one wavelength to another.

As for a wavelet coefficients in the case of mono-channel data,
we know the noise standard deviation relative to a coefficient,
and coefficients are of zero mean. Therefore, we can apply the same
filtering method. The filtered WT-PCA coefficients are found by minimizing
for each  $c_{l,j,k}$:
\begin{eqnarray}
j(\tilde c_{l,j,k}) = h_s(c_{l,j,k} -\tilde c_{l,j,k}) 
                      + \alpha h_n(\tilde c_{l,j,k})
\label{eqn_func_mc}
\end{eqnarray}

\subsubsection*{Example}

\begin{figure}[htb]
\centerline{
\hbox{ 
\psfig{figure=fig_simu20_noi12.ps,bbllx=3cm,bblly=2.8cm,bburx=18cm,bbury=17.4cm,width=7.5cm,height=8cm,clip=}
}}
\caption{Simulation: Root Mean Square Error versus the  noise standard deviation.
See text.}
\label{fig_simu20_noi12}
\end{figure}

Figure~\ref{fig_simu20_noi12} relates to a simulation using the same dataset 
as in the previous example (i.e., 
a dataset of 18 frames).
Additive noise was used, and the data were filtered. 
We  calculated the Root Mean Square Error
(RMSE) on each individual frame on a $5 \times 
5$ square centered on the source.
Hence, the RMSE reflects well the photometric errors, and the addition
of the 18 RMSE values, which we call IRMSE (Integrated RMSE), 
furnishes us a reliable measurement of the filtering quality.
The simulation was repeated with 12 noise levels, and four
different filtering methods were compared. Figure~\ref{fig_simu20_noi12}
shows the IRMSE versus the noise standard deviation plot. The four
methods are (i) multiscale entropy aaplied to 
the WT-KLT coefficients (diamond),
(ii) reconstruction from a subset of eigenvectors of the KLT (triangle),
(iii) multiscale entropy applied to each frame independently (square),
and (iv) thresholding applied to the wavelet transform of each frame (star).
This simulation shows clearly that the approach proposed here, multiscale
entropy applied to the WT-KLT coefficients, outperforms all other methods.

\begin{figure}[htb]
\centerline{
\hbox{ 
\psfig{figure=fig_planck_simu8_noi12.ps,bbllx=2.5cm,bblly=2.8cm,bburx=18cm,bbury=17.4cm,width=7.5cm,height=8cm,clip=}
}}
\caption{Planck Simulation: Root Mean Square Error versus the  noise standard deviation.
See text.}
\label{fig_planck_simu8_noi12}
\end{figure}

The same experiments were performed using a simulated Planck data set.
Planck is an upcoming European Space Agency mission to carry out measurements
of the cosmic microwave background.
The data set contains ten images, each one being a linear combination of
6 sky component images (CMB, SZ, free-free, etc.). As in the previous 
simulation, noise was added, and the data were filtered
by the four methods. The only difference is that the RMSE is calculated
on the full frames. Figure~\ref{fig_planck_simu8_noi12} shows 
IRMSE versus the noise standard deviation plot. Diamonds, triangles, 
squares and stars represent the same methods as before.
Again, the multiscale entropy applied to the WT-KLT coefficients outperforms 
the other methods.

\subsection{WT-KLT Filtering of 1D Multichannel Data: wk1d\_filter}
\label{sect_mc1d_filter}
\index{wk1d\_filter}
The program 
{\em wk1d\_filter} filters 
a multichannel signal (2D data set).
{\bf
\begin{center}
 USAGE: wk1d\_filter option data\_in data\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
 \itemsep=0.1truecm

\item {\bf [-n number\_of\_scales]}\\
see section~\ref{sect_mc_trans}.  
\item {\bf [-g sigma]}\\
 The image contains Gaussian noise, and the standard deviation is
given by {\em sigma}. This option should be set only if the user
knows the standard deviation of the noise. 
\item {\bf [-x]} \\
see section~\ref{sect_mc_trans}.  
% \item {\bf [-p]} \\
% Normalize the correlation matrix. Values on the diagonal are 1. 
% Default is no.
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-y NoiseCorrelationType]}
{\small
\begin{itemize}             
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item{0:} Compute the correlation matrix with all wavelet coefficients. 
\item{1:} Compute the correlation matrix only with significant wavelet coefficients. 
\item{2:} Compute the correlation matrix with weighted wavelet coefficients. 
\end{itemize}
} 
Default is 1.     
\item {\bf [-s NSigma]} \\
Wavelet coefficients are significant when their absolute values are larger
than nsigma * SigmaNoise. This option has an effect when 
the ``-y'' option is set to 1 or 2.
Default {\em NSigma} value is  3. 
\item {\bf [-S NSigma]} \\
The WT-KLT coefficients are  at {\em NSigma}*SigmaNoise.
Default is  3.
\item {\bf [-P]}\\
Positivity constraint. Default is not to enforce this.
\item {\bf [-F NbrEigenVect]} \\
Number of eigenvectors used for the reconstruction. 
Default is set to the number of images.
\item {\bf [-K EigenVect\_Number]} \\
Eigenvector number which will not be used for the reconstruction. 
\item {\bf [-C]}\\
see section~\ref{sect_mc_trans}.  
\end{itemize}

\subsubsection*{Examples}
\begin{itemize}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item wk1d\_filter input.fits output.fits \\
Filter the 1D multi-channel data set using the WT-KLT transform.
\item wk1d\_filter -S 5 input.fits output.fits \\
Ditto, but smooth the WT-KLT at 5 sigma instead of 3. 
\end{itemize}

\subsection{WT-KLT Filtering of 2D Multichannel Data: wk\_filter}
\index{wk\_filter}
\label{sect_mc_filter}
The program 
{\em wk\_filter} filters 
a multichannel image (3D data set).
{\bf
\begin{center}
 USAGE: wk\_filter option data\_in data\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item {\bf [-t type\_of\_multiresolution\_transform]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-T type\_of\_filters]}  \\ 
see section~\ref{sect_mc_trans}.
\item {\bf [-L]} \\
see section~\ref{sect_mc_trans}.
% \item {\bf [-u]} \\
% see section~\ref{sect_mc_trans}.  
\item {\bf [-n number\_of\_scales]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-g sigma]}\\
Noise standard deviation. Default is automatically calculated.
\item {\bf [-x]} \\
see section~\ref{sect_mc_trans}.  
% \item {\bf [-p]} \\
% Normalize the correlation matrix. Values on the diagonal are 1. 
% Default is no.
\item {\bf [-O Input\_CorrelMat\_FileName]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-y NoiseCorrelationType]}
{\small
\begin{itemize}             
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item{0:} Compute the correlation matrix with all wavelet coefficients. 
\item{1:} Compute the correlation matrix only with significant wavelet coefficients. 
\item{2:} Compute the correlation matrix with weighted wavelet coefficients. 
\end{itemize}
} 
Default is 1.     
\item {\bf [-s NSigma]} \\
Wavelet coefficients are significant when their absolute values are larger
than nsigma * SigmaNoise. This option has an effect when 
the ``-y'' option is set to 1 or 2.
Default {\em NSigma} value is  3. 
\item {\bf [-S NSigma]} \\
The WT-KLT coefficients are  at {\em NSigma}*SigmaNoise.
Default is  3.
\item {\bf [-P]}\\
Positivity constraint. Default is not to enforce this.
\item {\bf [-b]}\\
Maximum image constraint at 255.  Default is not to use this.
\item {\bf [-w]}\\
see section~\ref{sect_mc_trans}.  
\item {\bf [-F NbrEigenVect]} \\
Number of eigenvectors used for the reconstruction. 
Default is set to the number of images.
\item {\bf [-K EigenVect\_Number]} \\
Eigenvector number which will not be used for the reconstruction. 
\item {\bf [-C]}\\
see section~\ref{sect_mc_trans}.  
\end{itemize}
\subsubsection*{Examples}
\begin{itemize}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item wk\_filter in\_cube.fits out\_cube.fits \\
Filter the cube using all default options.
\item wk\_filter -S 5 in\_cube.fits out\_cube.fits\\
Threshold the WT-KLT coefficients at 5 sigma, instead of 3 sigma.
\item wk\_filter -S 5 -t24 in\_cube.fits out\_cube.fits\\
Ditto, but use an undecimated wavelet transform.
\end{itemize}

\subsection{WT-KLT Filtering of 2D Multichannel Data by the Multiscale
Entropy Method: wk\_memfilter}
\index{wk\_memfilter}
The program 
{\em wk\_memfilter} filters 
a multichannel image (3D data set) by the multiscale entropy method.
{\bf
\begin{center}
 USAGE: wk\_memfilter option cube\_in cube\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item {\bf [-t type\_of\_multiresolution\_transform]} \\
see section~\ref{sect_mc_trans}.
\item {\bf [-T type\_of\_filters]}  \\ 
see section~\ref{sect_mc_trans}.
\item {\bf [-L]} \\
see section~\ref{sect_mc_trans}.    
\item {\bf [-n number\_of\_scales]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-g sigma]}\\
see section~\ref{sect_mc1d_filter}.
\item {\bf [-x]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-O]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-y NoiseCorrelationType]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-s nsigma]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-P]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-b]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-w]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-F NbrEigenVect]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-K EigenVect\_Number]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-C CvgParam]} \\
Convergence parameter. Default is $1e-2$.
\item {\bf [-G RegulParam]} 
 Regularization parameter. Default is 1. 
\item {\bf [-U Type\_of\_Regularization]} 
{\small
\begin{enumerate}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item Use a fixed user Alpha value.
\item Estimate the optimal Alpha.
\item Estimate one Alpha value per band.
\end{enumerate}}
Default is 1.
\item {\bf [-D]} \\
Alpha is modified using the data SNR. Default is no.
\item {\bf [-i MaxIter]} \\
 Maximum number of iterations. Default is 20.
\end{itemize}
\subsubsection*{Examples}
\begin{itemize}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item wk\_memfilter -U 3 in\_cube.fits out\_cube.fits \\
Filtering using one regularization parameter per resolution level.
\item wk\_memfilter -U 3 -D in\_cube.fits out\_cube.fits \\
Ditto, but protect wavelet coefficients with high SNR from the regularization.
\item wk\_memfilter -t24 -U 3 -D in\_cube.fits out\_cube.fits \\
Ditto, but use the undecimated wavelet transform.
\end{itemize}



\section{Filtering using the Haar-Multichannel Transform}
\subsection{Definition}
We have seen in \proj \ that the Haar transform 
presents some advantages, especially when the data contains Poisson noise.

In order to decorrelate the information both spatially and in wavelength (or in
time), a 2D-wavelet transform
must first be performed on each frame of the date cube $D(x,y,z)$. 
We denote the result $w_{j,k_x,k_y,z}$, 
where $j$ is the scale index ($j \in [1,J]$, and
where $J$ is the number of scales), $k_x,k_y$ the 
spatial position in the scale ($k_x \in [0,N_x-1]$, and $k_y \in [0,N_y-1]$),
 and $z$ is the frame number. 
This set must again be transformed in order to 
decorrelate the information in the third dimension. We apply a 1D-transform
to each vector $w_{j,k_x,k_y,z}$, 
and we get a new set of data $u_{j,j^{'},k_x,k_y,k_z}$,
where $j^{'}$ and $k_z$ are respectively the scale index and position
in the third dimension.

Using the unnormalized Haar transform, 
a coefficient $u_{j+1,j^{'}+1,k,l,t}$ can be written
as:
\begin{eqnarray}
u_{j+1,j^{'}+1,k_x,k_y,k_z} 
   = \sum_{i=2^{j^{'}+1}k_z}^{2^{j^{'}}k_z+2^{j^{'}}-1} w_{j+1,k_x,k_y,i} -
     \sum_{i=2^{j^{'}+1}k_z+2^{j^{'}}}^{2^{j^{'}+1}(k_z+1)-1} w_{j+1,k_x,k_y,i}
\end{eqnarray}
We assume now a constant background rate $\lambda_i$ for each frame $i$ 
of the data cube. 
Each Haar wavelet coefficient $w_{j+1,k_x,k_y,i}$ is the difference between two
random variables $X_i$ and $Y_i$, which follows a Poisson distribution of
parameter $\lambda_{j,i}$, where $\lambda_{j,i}$ represents the rate per
pixel over $2^{j+1}$ pixels of the $i$th frame, and is equal to $2^{2j}\lambda-i$.
Then $u_{j+1,j^{'}+1,k_x,k_y,k_z}$ is the difference of 
 two variables, $X=\sum_i X_i$ and $Y=\sum_i Y_i$, and both follow a Poisson
 distribution of parameter $\sum_i \lambda_{j,i}$.
The thresholding method described in \proj 
can therefore be used, using the correct $\lambda$ value.

\subsubsection*{Filtering}

The multichannel filtering algorithm is:
\begin{enumerate}
\item For each frame $D(*,*,z)$, apply the 2D-Haar transform: we obtain 
$w_{j,k,l}(z)$.
\item For each scale $j$, and at each position $k_x,k_y$, 
extract the 1D vector
 $w_{j,k_x,k_y,*}$ and compute its wavelet transform. We get a new data set.
\item Threshold the coefficients using the correct $\lambda value$.
\item Inverse 1D transform.
\item Inverse 2D transform.
\end{enumerate}

For non-constant background, a coarse to fine approach, as explained in
\proj, can be used.

\subsection{WT-KLT Filtering of 2D Multichannel Data by the Multiscale
Haar Transform: ww\_filter}
\index{ww\_filter}
The program 
{\em ww\_filter} filters 
a multichannel image (3D data set) by applying a 2D  WT following
by a 1D WT in the third direction.
{\bf
\begin{center}
 USAGE: ww\_filter option data\_in data\_out
\end{center}}
where options are: 
\begin{itemize} 
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item {\bf [-t type\_of\_multiresolution\_transform]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-T type\_of\_filters]}  \\ 
see section~\ref{sect_mc_trans}.
\item {\bf [-L]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-n number\_of\_scales]} \\
see section~\ref{sect_mc_trans}.  
\item {\bf [-g sigma]}\\
see section~\ref{sect_mc1d_filter}.
\item {\bf [-s nsigma]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-S nsigma]} \\
see section~\ref{sect_mc_filter}.  
\item {\bf [-P]} \\
see section~\ref{sect_mc_filter}. 
\end{itemize}
\subsubsection*{Examples}
\begin{itemize}
\baselineskip=0.4truecm
\itemsep=0.1truecm
\item ww\_filter -t 18 -T 3 input.fits output.fits \\
Filtering using the Haar  wavelet transform.
\item ww\_filter -t 24 -T 3 input.fits output.fits \\
Ditto, but use an undecimated wavelet transform.
\item ww\_filter  -t 24 -T 3 -S 5 input.fits output.fits \\
Increase the thresholding level.
\end{itemize}

\newpage

\section{Independent Component Analysis}
\index{independent component analysis}
\index{blind source separation}
\index{ICA}

The idea of independent component analysis (ICA) originates from
the problem of {\em blind source separation} (BSS), and consists of
recovering unobserved signals or ``sources'' from several observed mixtures
\cite{mc:cardoso98}. Assuming that $n$ statistically independent 
signals $s_1(t), ..., s_n(t)$ are mixed by an unknown $n \times n$ mixing  
matrix $A=[a_{ij}]$, we have:
\begin{eqnarray}
X(t) = A S(t)
\end{eqnarray}
where $S(t) = [ s_1(t), \dots, s_n(t) ]^t$, and
 $X(t) = [ x_1(t), \dots, x_n(t) ]^t$ represents the observed signals, with 
 $x_i(t) = \sum_{j=1}^n a_{ij} s_j(t)$.  
The challenge is to find how to achieve separation using as our
only assumption that
the source signals are statistically independent. The solution  
consists of finding 
an $n \times n$ separating matrix $B$, $Y(t) = B S(t)$, such that   
$Y$ is an estimate of S.
This is achieved by minimizing contrast functions $\Phi$, which are defined 
in terms of the Kullback-Leibler divergence  $K$:
\index{Kullback-Leibler}
\begin{eqnarray}
\Phi(Y) = \int p_Y(u) \log{ {p_Y(u) \over \prod p_{Y_i}(u_i) }} du
\end{eqnarray}

The mutual information, expressed by the  Kullback-Leibler divergence, 
vanishes if and only if the variables
$Y_i$ are mutually independent, and is strictly positive otherwise.

ICA has been used in astronomy to analyze multispectral 
images \cite{mc:bijaoui00} of the galaxy 3C 120 and to separate 
\index{data!\texttt{3}C120}
the Cosmic Microwave Background
\index{Cosmic Microwave Background}
from other sky components \cite{mc:bacci00}.
As for PCA, it has been shown \cite{mc:zibu99,mc:zibu01} that applying 
ICA to  wavelet transformed signals leads to better quality results,
especially in the presence of noise.

\subsection*{Example}
Fig.~\ref{fig_ica1} shows three simulated signals. Six observed data sets
were derived from the three sources, by a linear combination
(see Fig.~\ref{fig_ica2}). Without any knowledge of the mixing matrix,
the JADE-ICA \cite{mc:cardoso98} method was applied and the 
three signals were
reconstructed from the six observed data sets (see Fig.~\ref{fig_ica3}).

\begin{figure}[htb]
\centerline{
\hbox{ 
\psfig{figure=fig_ica_source.ps,bbllx=2cm,bblly=12.5cm,bburx=20cm,bbury=25.5cm,width=9cm,height=7.5cm,clip=}
}}
\caption{Example of three simulated sources.}
\label{fig_ica1}
\end{figure}

\begin{figure}[htb]
\centerline{
\hbox{ 
\psfig{figure=fig_ica_obs_signal.ps,bbllx=2cm,bblly=12.5cm,bburx=20cm,bbury=25.5cm,width=9cm,height=7.5cm,clip=}
}}
\caption{Mixed sources. Each of these six signals is a linear combination
of the three simulated sources.}
\label{fig_ica2}
\end{figure}

\begin{figure}[htb]
\centerline{
\hbox{ 
\psfig{figure=fig_ica_demixing.ps,bbllx=2cm,bblly=12.5cm,bburx=20cm,bbury=25.5cm,width=9cm,height=7.5cm,clip=}
}}
\caption{Reconstructed sources from the mixed signals.}
\label{fig_ica3}
\end{figure}

\subsection{JADE-ICA IDL Programs}
 
\subsubsection{JADE}
\label{jade}
\index{JADE}
 Apply the Independant Componant Method to a set of vectors using
the JADE method.
{\bf
\begin{center}
 USAGE:  jade, ObservSig, NbSource, DeMixingMat, Process, Verbose=Verbose
\end{center}}
where
\begin{itemize}
\item {\em  ObservSig:} Input Data (ObservSig = $A$ \# original signal).
ObservSig$(i,*)$ = $i$th vector.
\item {\em  NbSource:}  Input number of sources in the input signal.
\item {\em DeMixingMat:} Output demixing matrix.
\item {\em Process:} Output Reconstructed process = DeMixingMat \# ObservSig.
Process$(i, *)$ = $i$th Process, with $i = 0.. {\mathrm NbSource} - 1$.
\end{itemize}


\subsubsection{JADE1D}
Apply the Independant Componant Method to a set of vectors using
the JADE method. The routine is identical to jade routine, except
that the input-output vectors are ordered differently ($V(*,i)$ for
the $i$th vector, instead of $V(i,*)$).
{\bf
\begin{center}
 USAGE:  jade1d, ObservSig, NbSource, DeMixingMat, Process, Verbose=Verbose
\end{center}}
where
\begin{itemize}
\item {\em  ObservSig:} Input Data (ObservSig = $A$ \# original signal).
;                    ObservSig$(*,i)$ = $i$th vector.
\item {\em  NbSource:}  Input number of sources in the input signal.
\item {\em DeMixingMat:} Output demixing matrix.
\item {\em Process:} Output Reconstructed process = DeMixingMat \# ObservSig.
Process$(*, i)$ = $i$th Process, with $i = 0.. {\mathrm NbSource} - 1$.
\end{itemize}

\subsubsection{JADE2D}
Apply the Independant Componant Method to a set of images using
the JADE method. The routine is an extension to 2d of jade1d routine.
The input set of images must be given with the following syntax:
ObservSig$(*, *, i)$ = $i$th image. If the ``/wave'' keyword is set,
a 2D wavelet transform is first perform on each image, JADE is applied
on the wavelet transformed images, and an inverse wavelet transform
is applied on the reconstructed process. The wavelet transform is
performed by calling the program {\em mr\_transform}. 
{\bf
\begin{center}
 USAGE: jade2d, ObservSig, NbSource, DeMixingMat, Process, wave=wave, optw=optw, Verbose=Verbose
\end{center}}
where
\begin{itemize}
\item {\em  ObservSig:} Input Data (ObservSig = $A$ \# original signal).
ObservSig$(*,*,i)$ = $i$th vector.
\item {\em  NbSource:}  Input Number of sources in the input signal.
\item {\em DeMixingMat:} Output demixing matrix.
\item {\em Process:} Output Reconstructed process = DeMixingMat \# ObservSig.
Process$(*, *, i)$ = $i$th Process, with $i = 0.. {\mathrm NbSource} - 1$.
\item {\em wave::} if set, an bi-orthogonal wavelet transform is applied
on each image, and the component separation is performed
on the wavelet transformed images.
The inverse wavelet transform is then applied on the
reconstructed process.
\item {optw:} string = options for the wavelet transformation
\end{itemize}

\subsubsection*{Examples:}
\begin{itemize}
\item jade2d,  ObservIma, NbSource, DeMixingMat, RecIma \\
Apply the JADE method to {\em ObservIma}. 
\item jade2d, ObservIma, NbSource, DeMixingMat, RecIma, /wave, optw='-n5'\\
Ditto, but applied a wavelet transform with five scales on each image.
\end{itemize}
