h28390
s 00209/00090/01987
d D 1.3 10/05/12 19:24:01 starck 3 2
c update olivier
e
s 00136/00005/01941
d D 1.2 10/02/18 18:31:30 starck 2 1
c Update doc
e
s 01946/00000/00000
d D 1.1 10/02/18 09:30:29 starck 1 0
c date and time created 10/02/18 09:30:29 by starck
e
u
U
f e 0
t
T
I 1

\chapter{IDL Routines}
\label{ch_mrs_idl}
%\chapterhead{IDL Routines}
\markright{IDL Routines}


\section{Introduction}
I 2
 
D 3
The IDL software  (\texttt{http://www.idl-envi.com}) is analogous to Matlab and is very widely used in astrophysics and in medical imaging.  
HEALPix is available at \\
\texttt{http://sourceforge.net/projects/healpix}.
E 3
I 3
The IDL software (\texttt{http://www.idl-envi.com}) is analogous to Matlab and is very widely used in astrophysics and in medical imaging.  
HEALPix is available at:\\ \\
{\centerline{\texttt{http://sourceforge.net/projects/healpix}}}\\
E 3

MR/S is a collection of IDL files that implements all the multiscale transforms described in 
D 3
this document, using HEALPix pixelization. The library is available via the web site: \\
{\centerline{\texttt{http://jstarck.free.fr/iSAP.html}}}
E 3
I 3
this document, using HEALPix pixelization. The library is available via the web site:\\ \\
{\centerline{\texttt{http://jstarck.free.fr/iSAP.html}}}\\
E 3

E 2
A set of routines has been developed in IDL. Starting IDL using the script program {\em mrs.pro} allows the user 
to get the multiresolution environment on the sphere, and all routines described in the following can be called. 
An online help facility is also available by invoking the {\em mrsh} program under IDL.

D 2

E 2
\section{Installation}
\index{installation}

D 2
The MRS package requires that IDL (version 6.0 or later) and HEALPix (version 2.0) be installed. The HEALPix environment 
E 2
I 2
D 3
The MRS package requires   IDL (version 6.0 or later) and HEALPix (version 2.0 or later) to be installed. The HEALPix environment 
E 2
E 3
I 3
The MRS package requires IDL (version 6.0 or later) and HEALPix (version 2.0 or later) to be installed. The HEALPix environment 
E 3
variable \textbf{HEALPix} is expected to be defined. The alias \textbf{idl} should also be defined to launch the IDL environment. 
Then, installing the MRS package simply requires adding some lines in your shell environment profile:
\begin{itemize}
\item[$\bullet$] {define the environment variable \textbf{MRS}}  
\begin{verbatim}
D 2
setenv MRS /home/user/mrs_1.0
E 2
I 2
setenv MRS /home/user/mrs_2.0
E 2
\end{verbatim}
 \item[$\bullet$]{define the alias \textbf{mrs}}  
\begin{verbatim}
alias mrs 'idl $MRS/idl/mrs.pro' 
\end{verbatim}
\end{itemize}
D 2
Then the command "mrs" will start the IDL session using the MRS environment. Test program examples can be found 
in \$MRS/idl (test\_mrs.pro, test\_mrs\_smica.pro, \dots). These routines use data in directory \$MRS/data.
E 2
I 2
D 3
Then the command "mrs" will start the IDL session using the MRS environment. 
 HEALPix binary must be in the user path.
E 3
I 3
Then the command "mrs" will start the IDL session using the MRS environment. HEALPix binary must be in the user path.
E 3
 
\section{Input Data}
D 3
  

E 3
I 3
Most of the functions of MRS package are working with spherical maps either as input or as output variables. The maps could be in 
two possible kind of formats: the first one which will be recognized by all functions is the Healpix format. This format allows 
two kind of pixel order in the data array called NESTED and RING. Unless stated, MRS functions will work only with NESTED maps. 
Conversions between NESTED and RING schemes could be done with the function "REORDER" from Healpix package. The second format which 
is recognized by some functions of MRS package but not all is the GLESP format. In IDL, the variable for an image in GLESP format 
is an IDL structure. The MRS package include the file "mrs\_glesp.pro" which contains several functions for working with GLESP images 
especially the functions "healpix2glesp" and "glesp2healpix" which are used for the conversions between Healpix and GLESP format.
E 3

\section{Global MR/S Variable}
D 3
Four global MRS variables, defined in the file "mrs.pro",  are available, and can be changed by the user.
E 3
I 3
Four global MRS variables, defined in the file "mrs.pro", are available, and can be changed by the user.
E 3
\begin{itemize}
\item HealpixCXX: default is 1. By default, MRS uses Healpix C++ programs to compute the spherical harmonic coefficients. 
If HealpixCXX is set to 0, MRS will call the Healpix  Fortran programs. We recommend to keep HealpixCXX equal to 1. Fortran option
will not be supported in the future.
\item DEF\_ALM\_FAST: default is 1. By default, spherical harmonic coefficients are calculated with floating values. This is faster and requires less
memory, but is not as accurate than using double. Set DEF\_ALM\_FAST to zero to make all calculation with double.
\item DEF\_ALM\_NITER: default is 10. This variable is only used when DEF\_ALM\_FAST is equal to zero. DEF\_ALM\_NITER is the number of iterations
used by HEALPix to compute the spherical harmonic coefficients. In the fast mode (default mode), there is no iteration.
\item DEF\_NORM\_POWSPEC: default is 0. If DEF\_NORM\_POWSPEC is set to 1, the commande "mrs\_powspec" will return a normalized power spectrum, 
such that a map containing a Gaussian noise with variance 1 will have a power spectrum equal to 1. 
\end{itemize}
E 2


\section{General functions for spherical maps}
\index{general}

\subsection{Reading a spherical map from a file : mrs\_read}
\index{IDL routines!mrs\_read}
\index{general!read map}
Read a spherical map, either in HEALPIX or in GLESP format.
{\bf
\begin{center}
     USAGE: map = mrs\_read( file )
\end{center}}
where
\begin{itemize}
\item {\em file} : Input string, name of the file to be read. The pathname can be included in the string, by default 'file.fits' is equivalemt to './file.fits'
\item {\em map} : Output IDL array of Healpix map or Glesp image IDL structure, map read. For a Healpix map, the map is setted to the NESTED format after reading.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item healmap = mrs\_read( 'my\_file\_healpix.fits' ) \\
Read the map stored into the file 'my\_file\_healpix.fits' and load it into healmap.
\end{itemize}



\subsection{Writing a spherical map into a file : mrs\_write}
\index{IDL routines!mrs\_write}
\index{general!write map}
Write a spherical map, either in HEALPIX with the NESTED format or in GLESP format.
{\bf
\begin{center}
     USAGE: mrs\_write, file, map, ring=ring
\end{center}}
where
\begin{itemize}
\item {\em file} : Input string, name of the file to be writen. The pathname can be included in the string, by default 'file.fits' is equivalemt to './file.fits'
\item {\em map} : Input IDL array of Healpix map or Glesp image IDL structure, to be writen. For a Healpix map, the map is assumed to be in the NESTED format.
\item {\em ring} : scalar, if set convert the Healpix map data to the RING format for the writing.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_write, 'my\_file\_healpix.fits', healpixdata, /ring \\
Write the map healpixdata into the file 'my\_file\_healpix.fits' as a ring image.
\end{itemize}



\subsection{Ploting a spherical map on the screen : mrs\_tv}
\index{IDL routines!mrs\_tv}
\index{general!plot map}
Visualization of a Healpix image (nested data representation) or a GLESP image.
{\bf
\begin{center}
     USAGE: mrs\_tv, Data, graticule=graticule, gif=gif, png=png, title=title, colt=colt, nobar=nobar, 
     Healpix=Healpix, PS=PS, log=log, min=min, max=max, pxsize=pxsize, big=big, x=x, pol=pol, units=units
\end{center}}
where
\begin{itemize}
\item {\em Data} : Input IDL array of Healpix map or Glesp image IDL structure, map to be visualized.
\item {\em min} : float, Data image is visualized with the new min set.
\item {\em max} : float, Data image is visualized with the new max set.
\item {\em log} : scalar, if set plot the image in log scale, Data must be positive.
\item {\em graticule} : int, Mollview Healpix command graticule keyword, see mollview Healpix documentation for more details.
\item {\em png} : string, if set write to the disk a PNG file with the filename given by the png keyword.
\item {\em gif} : string, if set write to the disk a GIF file with the filename given by the gif keyword.
\item {\em PS} : string, if set write to the disk a Postcript file with the filename given by the ps keyword.
\item {\em title} : string, if set add the string as a title of the plot in the Healpix representation.
\item {\em unit} : string, name of the image's unit to be plotted with the Look Up Table in the Healpix representation.
\item {\em colt} : int, IDL Color table.
\item {\em nobar} : scalar, if set do not plot the Look Up Table in the Healpix representation.
\item {\em healpix} : scalar, if set then convert the GLESP image into a Healpix one, and use the Healpix 
representation for visualization. This keyword is not active for maps already in Healpix representation.
\item {\em pxsize} : int, set the number of horizontal pixel on the plot (it will be the same in vertical), default value is 800.
\item {\em big} : scalar, if set pxsize is setted to 1500.
\item {\em pol} : int, keyword for plotting polarized map T,Q,U. Default value is 0 (no polarized map), see mollview Healpix documentation for more details.
\item {\em x} : scalar, if set start interactive plot with the mapview prog, nside max=1024, data will be resized if greater.
\end{itemize}



\subsection{Resizing a spherical map: mrs\_resize}
\index{IDL routines!mrs\_resize}
\index{general!map resizing}
Resize map either in Healpix (nested format) or Glesp representation
{\bf
\begin{center}
     USAGE: resize\_map = mrs\_resize( map, nside=nside, nx=nx, np=np, ViaAlm=ViaAlm )
\end{center}}
where
\begin{itemize}
\item {\em map} : Input IDL array of Healpix map or Glesp image IDL structure to be transformed.
\item {\em resize\_map} : Output IDL array of Healpix map or GLESP image IDL structure. Healpix input map and output resized map are in nested format.
\item {\em nside} : int, the new nside parameter of the output healpix resized map.
\item {\em nx} : int = number of rings of the resized Glesp map.
\item {\em np} : int = max number of pixel on a ring of the resized Glesp map.
\item {\em ViaAlm} : scalar, if set use alm transform for the resizing, otherwise, use interpolation. 
Ignored if nside keyword value is lower than imag nside, Healpix only.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item map2 = mrs\_resize( map, nside = 256 ) \\
resize an Healpix map.
\item map2 = mrs\_resize( map, nx = 512, np = 1024 ) \\
resize a Glesp map.
\end{itemize}



\subsection{Spliting of a spherical map into patches: mrs\_split}
\index{IDL routines!mrs\_split}
\index{general!map spliting}
Decompose an healpix map (nested format) into a cube of small patches.
{\bf
\begin{center}
D 3
     USAGE: PatchTrans = mrs\_split( Imag, frac=frac, nx=nx, SizePatchDegrees=SizePatchDegrees, exrec=exrec, PixelSizeParam=PixelSizeParam )
E 3
I 3
     USAGE: PatchTrans = mrs\_split( Imag, frac=frac, nx=nx, exrec=exrec, SizePatchDegrees=SizePatchDegrees, PixelSizeParam=PixelSizeParam )
E 3
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map to be to be decomposed into patches.
\item {\em PatchTrans} : Output IDL structure with the following fields:
\begin{itemize}
\item {\em NMaps} : long, number of patches.
\item {\em map\_hd} : string, header of a small patch.
\item {\em Nx} : long, size of each patch in the x axis.
\item {\em Ny} : long, size of each patch in the y axis.
D 3
\item {\em Lon} : float array[NMaps], Longitude of each patches if the position (Nx/2.,Ny/2.) is the center of the patches.
\item {\em Lat} : float array[NMaps], Latitude of each patches if the position (Nx/2.,Ny/2.) is the center of the patches.
\item {\em Map} : float array[Nx,Nx,NMaps], cube of the patches.
E 3
I 3
\item {\em Lon} : float array[ NMaps ], Longitude of each patches if the position (Nx/2,Ny/2) is the center of the patches.
\item {\em Lat} : float array[ NMaps ], Latitude of each patches if the position (Nx/2,Ny/2) is the center of the patches.
\item {\em Map} : float array[ Nx, Nx, NMaps ], cube of the patches.
E 3
\item {\em PixelSize} : float, pixel size in arc minute.
\item {\em MapSize} : float, map size in arc minute.
\item {\em Frac} : float, overlapping factor between patches.
\item {\em Nside} : long, nside parameter of the input imag.
\end{itemize}
\item {\em Frac} : float, overlapping factor between patches. Default is 0.05
\item {\em Nx} : long, size of each patch along both x and y axis. Default is automatically estimated.
\item {\em SizePatchDegrees} : float, size (in degrees) of each patch. Default is 10 degrees.
\item {\em exrec} : scalar, if set the pixel size is smaller in order to have an exact reconstruction using mrs\_invsplit
D 3
\item {\em PixelSizeParam} : float, if exrec is setted, the pixel size is multiplied by this factor (< 1) in order to smaller pixel for exact reconstruction.
E 3
I 3
\item {\em PixelSizeParam} : float, if exrec is setted, the pixel size is multiplied by this factor ($< 1$) in order to smaller pixel for exact reconstruction.
E 3
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item Patch = mrs\_split( map ) \\
Decompose an image into patches with default options.
\end{itemize}



\subsection{Reconstruction of a spherical map from its patches: mrs\_invsplit}
\index{IDL routines!mrs\_invsplit}
\index{general!map inverse spliting}
Reconstruct a healpix map (nested format) from a cube of small patches obtained by the routine mrs\_split.
{\bf
\begin{center}
     USAGE: Map = mrs\_invsplit( PatchTrans )
\end{center}}
where
\begin{itemize}
\item {\em PatchTrans} : Output IDL structure with the following fields:
\begin{itemize}
\item {\em NMaps} : long, number of patches.
\item {\em map\_hd} : string, header of a small patch.
\item {\em Nx} : long, size of each patch in the x axis.
\item {\em Ny} : long, size of each patch in the y axis.
D 3
\item {\em Lon} : float array[NMaps], Longitude of each patches if the position (Nx/2.,Ny/2.) is the center of the patches.
\item {\em Lat} : float array[NMaps], Latitude of each patches if the position (Nx/2.,Ny/2.) is the center of the patches.
\item {\em Map} : float array[Nx,Nx,NMaps], cube of the patches.
E 3
I 3
\item {\em Lon} : float array[ NMaps ], Longitude of each patches if the position (Nx/2,Ny/2) is the center of the patches.
\item {\em Lat} : float array[ NMaps ], Latitude of each patches if the position (Nx/2,Ny/2) is the center of the patches.
\item {\em Map} : float array[ Nx, Nx, NMaps ], cube of the patches.
E 3
\item {\em PixelSize} : float, pixel size in arc minute.
\item {\em MapSize} : float, map size in arc minute.
\item {\em Frac} : float, overlapping factor between patches.
\item {\em Nside} : long, nside parameter of the input imag.
\end{itemize}
\item {\em Map} : Output IDL array of Healpix map reconstructed from the patches.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item map = mrs\_invsplit( Patch ) \\
Reconstruct an image from patches.
\end{itemize}



I 3

\subsection{Transformations of a spherical map : mrs\_trans}
\index{IDL routines!mrs\_trans}
\index{general!transforms of spherical image}
Compute a transform (wavelet, curvelet\ldots) on a map on the sphere in the Healpix representation (nested data representation).\\ \\
The transoform can be:
\begin{enumerate}
\item Spherical Harmonic Transform.
\item Orthogonal wavelet (per face).
\item A trou undecimated wavelet transform (per face).
\item Pyramidal isotropic wavelet on the sphere.
\item Undecimated wavelet transform on the sphere.
\item Ridgelet transform on the sphere.
\item Curvelet transform on the sphere.
\item Discrete Cosine Transform (per face).
\end{enumerate}
The input image must be in the HEALPix pixel representation (nested data representation). The output is a IDL structure.
{\bf
\begin{center}
     USAGE: mrs\_trans, InImag, Trans, NbrScale=NbrScale, Alm=Alm, AT=AT, Cur=Cur, UWT=UWT, PyrWT=PyrWT, OWT=OWT, Rid=Rid, DCT=DCT, 
     					lmax=lmax, FirstBlockSize=FirstBlockSize, DifInSH=DifInSH, MeyerWave=MeyerWave, Overlap=Overlap
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input 1D IDL array of healpix map in nested format. Input image to be transformed.
\item {\em Trans} : Output IDL structure with the following fields:
\begin{itemize}
\item {\em NbrScale} : int, number of scales.
\item {\em nside} : int, Healpix nside parameter.
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space.
\item {\em npix} : long, number of pixels of the input image.
\item {\em MeyerWave} : int, 1 if the keyword MeyerWave used, otherwise 0.
\item {\em DifInSH} : int, 1 if the keyword DifInSH used, otherwise 0.
\item {\em pyrtrans} : int, 1 if a pyramidal decomposition has been applied, otherwise 0.
\item {\em DEC1} : IDL structure, transformation result (depends on the chosen transform).
\item {\em TransChoice} : string, code of the chosen transform.
\item {\em TabCodeTransform} : string array, array of transforms codes. TabCodeTransform = ['T\_ALM', 'T\_OWT', 'T\_AT', 'T\_PyrWT', 'T\_UWT', 'T\_Ridgelet', 'T\_CUR', 'T\_DCT']
\item {\em TransName} : string, transform's name.
\item {\em TransTypeName} : string array, array of transforms names. 
TransTypeName = ['Alm','Bi-Orthogonal WT', 'A\_Trous WT', 'Pyramidal WT', 'Undecimated WT', 'Ridgelet Transform', 'Curvelet', 'DCT']
\end{itemize}
\item {\em NbrScale} : int, number of scales of the wavelet transforms.
\item {\em Alm} : scalar, if set perform a Spherical Harmonic Transform. If no transform is selected, it will be the default transformation.
\item {\em Cur} : scalar, if set perform a curvelet transform.
\item {\em uwt} : scalar, if set perform an undecimated isotropic wavelet transform.
\item {\em PyrWT} : scalar, if set perform a pyramidal isotropic wavelet transform.
\item {\em owt} : scalar, if set perform a bi-orthogonal wavelet transform on each face.
\item {\em AT} : scalar, if set perform a A trou undecimated wavelet transform on each face.
\item {\em Rid} : scalar, if set perform a Ridgelet transform on the sphere.
\item {\em DCT} : scalar, if set perform a Discrete Cosine Transform (per face).
\item {\em Overlap} : int, if equal to 1 if blocks are overlapping, only used with curvelet transform.
\item {\em FirstBlockSize} : int, block size in the ridgelet transform at the finest scale (default is 16), only used with curvelet transform.
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space (for isoptropic wavelet transform only).
\item {\em DifInSH} : Input keyword parameter. If set, the wavelet coefficients are computed as the difference between two resolutions in the spherical harmonics representation. 
Otherwise, the wavelet coefficients are computed as the difference between two resolutions in direct space. Only used with keyword uwt or PyrWT.
\item {\em MeyerWave} : If set, use Meyer wavelets and set the keyword DifInSH. Only used with keyword uwt or PyrWT.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_trans, Imag, WT, NbrScale=5, /uwt \\
Compute the undecimated wavelet transform of the map Imag with five scales. The result is stored in WT.
\end{itemize}



\subsection{Reconstructions of a spherical map : mrs\_rec}
\index{IDL routines!mrs\_rec}
\index{general!inverse transform of spherical image}
Compute a inverse transform (wavelet, curvelet\ldots) to get a map on the sphere in the Healpix representation 
(nested data representation) from its decomposition obtained by mrs\_trans.\\ \\
The transoform can be:
\begin{enumerate}
\item Spherical Harmonic Transform.
\item Orthogonal wavelet (per face).
\item A trou undecimated wavelet transform (per face).
\item Pyramidal isotropic wavelet on the sphere.
\item Undecimated wavelet transform on the sphere.
\item Ridgelet transform on the sphere.
\item Curvelet transform on the sphere.
\item Discrete Cosine Transform (per face).
\end{enumerate}
{\bf
\begin{center}
     USAGE: mrs\_rec, Trans, Rec
\end{center}}
where
\begin{itemize}
\item {\em Trans} : Input IDL structure, see mrs\_trans for more details.
\item {\em Rec} : Output 1D IDL array of healpix map in nested format. Reconstructed image.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_trans, Imag, WT, NbrScale=5, /uwt \\
Compute the undecimated wavelet transform of the map Imag with five scales. The result is stored in WT.
\item mrs\_rec, WT, RecIma \\
Reconstruct the image.
\end{itemize}




E 3
\section{Spherical Harmonics}
\index{spherical harmonics}

\subsection{ALM transform : mrs\_almtrans}
\index{IDL routines!mrs\_almtrans}
\index{spherical harmonics!ALM transform}
Computes the spherical harmonic transform, using the Healpix representation (nested data representation by default) or the GLESP data representation.
{\bf
\begin{center}
     USAGE: mrs\_almtrans, Imag, Trans, lmax=lmax, ring=ring, tab=tab, complex=complex, psp=psp, norm=norm
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure. Input image to be transformed.
\item {\em Trans} : Output IDL structure with the following fields:
\begin{itemize}
\item {\em ALM} : array of the ALM coefficients
\begin{center}
ALM = fltarray[*,2] list of the real part (ALM[*,0]) and imaginary part (ALM[*,1]) of the ALM. This is the default storage.\\
ALM = cfarr[*] list of the ALM in complex values format if the keyword complex is set.\\
ALM = fltarray[NbrMaxM, NbrMaxL, 2] table of the real part (ALM[*,*,0]) and imaginary part (ALM[*,*,1]) of the ALM if the keyword tab is set.\\
ALM = cfarr[NbrMaxM, NbrMaxL] table of the ALM in complex values format if the keywords complex and tab are both setted. By default, NbrMaxM = NbrMaxL = lmax+1
\end{center}
\item {\em complex\_alm} : int, 0 (default value) if ALM array contains real and imaginary part separated. 
1 if ALM is a complex array. 2 if ALM array contains the power spectrum and the phase.
\item {\em PixelType} : int, 0 for a Healpix input map and 1 for a GLESP input map.
\item {\em tab} : int, 0 for default ALM representation as a list (i.e. 1D IDL array) and 1 for 2D 
representation as a table (i.e. l for the first dimension and m for the second).
\item {\em nside} : int, Healpix nside parameter, only used in Healpix representation, otherwise, 0.
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space.
\item {\em npix} : long, number of pixels of the input image (12*nside*nside for Healpix).
\item {\em nx} : int = number of rings (Glesp parameter), otherwise, 0.
\item {\em np} : int = max number of pixel on a ring (Glesp parameter), otherwise, 0.
\item {\em x\_sky} : float array with COS( THETA ) for each ring (Glesp parameter), otherwise, 0.
\item {\em y\_sky} : long array number of pixels/ring (Glesp parameter), otherwise, 0.
\item {\em TabNbrM} : int array[NbrMaxL], max number of m value for a given l, only used if keyword tab is set otherwise, 0.
\item {\em index} : long array, indicies of the ALM coefficients, used only if keyword tab is not set.
\item {\em NormVal} : float, normalization value applied to the alm coefficients (only if keyword norm used).
\item {\em norm} : int, 0 if no normalization has been aplied, else 1.
\end{itemize}
\item {\em Lmax} : int, Number of spherical harmonics computed in the decomposition. For a Healpix map, default is 
3*nside and should be between 2*nside and 4*nside. For a GLESP map, default is: min([Imag.nx/2, Imag.np/4]).
\item {\em ring} : scalar, if set the input Healpix map is supposed to be in RING representation, ignored with GLESP images.
\item {\em Tab} : scalar, if set, ALM coefficients in Trans.alm are stored in a 2D array: Trans.alm[m,l] where m = 0..Trans.TabNbrM[l]-1  and l = 0..lmax-1
\item {\em complex} : scalar, if set Trans.alm will contain complex values instead of the real and imaginary parts.
\item {\em psp} : scalar, if set Trans.alm will contain the power spectrum and the phase instead of the real and imaginary parts. This is ignored if keyword complex is also set.
\item {\em norm} : scalar, if set, a normalization is performed to the alm coefficients.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_almtrans, Imag, Output \\
Compute the spherical harmonics transform of an image, the result is stored in Output.
\end{itemize}



\subsection{ALM inverse transform : mrs\_almrec}
\index{IDL routines!mrs\_almrec}
\index{spherical harmonics!ALM inverse transform}
Computes the inverse spherical harmonic transform, using the Healpix representation (nested data representation by default) or the GLESP representation.
{\bf
\begin{center}
     USAGE: mrs\_almrec, Trans, Imag, to\_healpix=to\_healpix, to\_glesp=to\_glesp, pin=pin, nx=nx, np=np, pixel\_window=pixel\_window
\end{center}}
where
\begin{itemize}
\item {\em Trans} : Input IDL structure of ALM coefficients, see mrs\_almtrans above for details.
\item {\em Imag} : Output IDL array of Healpix map (if Trans.pixeltype=0) or Glesp image IDL structure (if Trans.pixeltype=1). 
Image reconstructed, Healpix images are only reconstructed in nested representation.
\item {\em to\_healpix} : int, if to\_healpix=1, the reconstructed image will be in Healpix format instead of GLESP. 
If Trans.pixeltype=0 (already healpix), generates an error. If to\_healpix > 1, force the output to be in Healpix 
format with nside = to\_healpix (must be a valid value)
\item {\em to\_glesp} : scalar, if set the reconstructed image will be in GLESP format instead of healpix. If Trans.pixeltype=1 (already GLESP), generates an error.
\item {\em nx} : int, new number of rings for the reconstructed GLESP image (should be equal to 4*nside), nx must be larger than 2*lmax.
\item {\em np} : int, new number of pixels for the central ring of the reconstructed GLESP image (should be equal to 8*nside) np must be larger than 4*lmax.
\item {\em pixel\_window} : scalar, if set the image is convolved by the healpix pixel window (only for Healpix map).
\item {\em pin} : int, GLESP parameter -1 for equal aera (default), 0 for iso lat/lon (Theta-Phi image), 1 for triangular \dots
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_almtrans, Imag, Output \\
Compute the spherical harmonics transform of an image, the result is stored in Output.
\item mrs\_almrec, Output, Rec \\
Reconstruct the image.
\end{itemize}



\subsection{Power spectrum exctraction from ALM : mrs\_alm2spec}
\index{IDL routines!mrs\_alm2spec}
\index{spherical harmonics!Power spectrum exctraction from ALM}
Compute the power spectrum $C(l)$ from the $A_{l,m}$ coefficients.
\begin{equation}
D 3
C(l) = 1/(2l+1) sum_{m=-l}^{m=l} \mid A_{l,m} \mid^2
E 3
I 3
C(l) = \frac{1}{2l+1} \sum_{m=-l}^{m=l} \mid A_{l,m} \mid^2
E 3
\end{equation}
{\bf
\begin{center}
     USAGE: spec = mrs\_alm2spec( ALM, StdPS=StdPS )
\end{center}}
where
\begin{itemize}
\item {\em ALM} : Input IDL structure of ALM coefficients, see mrs\_almtrans above for details.
\item {\em spec} : Output 1D IDL float array[ALM.lmax+1]: Power spectrum $C(l)$ extracted from the ALM coefficients.
\item {\em StdPS} : 1D IDL float array[ALM.lmax + 1]: estimated standard deviation of the $C_l$ coefficients.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_almtrans, Imag, Output \\
Compute the spherical harmonics transform of an image, the result is stored in Output.
\item spec = mrs\_alm2spec( Output, StdPS=StdPS ) \\
Compute the power spectrum of the image and it's associated standard deviation.
\end{itemize}



\subsection{Power spectrum exctraction from an image : mrs\_powspec}
\index{IDL routines!mrs\_powspec}
\index{spherical harmonics!Power spectrum exctraction from an image}
Computes the power spectrum of a map, using the Healpix representation (nested data representation by default) 
or the GLESP representation. If the keyword log is set, it is the log-power spectrum which is returned. 
D 3
By default a normalisation is applied on the ALM coefficents.
E 3
I 3
If the global variable DEF\_NORM\_POWSPEC equal to 1 or if the keyword /set\_norm is set, then a normalization is 
performed, so that a Gaussian randomn noise with variance equal to 1 has a power spectrum equal to 1.
E 3
{\bf
\begin{center}
D 3
     USAGE: spec = mrs\_powspec( Imag, plot=plot, lplot=lplot, log=log, IndL=IndL, PowSpecIma=PowSpecIma, StdPS=StdPS, nonorm=nonorm, NormVal=NormVal, alm=alm, lmax=lmax )
E 3
I 3
     USAGE: spec = mrs\_powspec( Imag, plot=plot, lplot=lplot, log=log, IndL=IndL, PowSpecIma=PowSpecIma, StdPS=StdPS, set\_norm=set\_norm, nonorm=nonorm, NormVal=NormVal, alm=alm, lmax=lmax )
E 3
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure. Input image whose power spectrum will be extracted.
\item {\em spec} : Output 1D IDL float array[Lmax+1]: Power spectrum $C(l)$ extracted from the map.
\item {\em plot} : scalar, if set the power spectrum is plotted.
\item {\em lplot} : scalar, if set the power spectrum multiplied by l(l+1) is plotted.
\item {\em log} : scalar, if set the log power spectrum is calculated instead of the power spectrum.
\item {\em Lmax} : int, number of spherical harmonics computed in the decomposition and size of the computed spectrum (Lmax+1). 
For a Healpix map, default is 3*nside and should be between 2*nside and 4*nside. For a GLESP map, default is: min([Imag.nx/2, Imag.np/4]).
\item {\em nonorm} : scalar, if set no normalisation is applied on the ALM computed.
I 3
\item {\em set\_norm} : scalar, if set a l2 normalization if perform, so a Gaussian randomn noise with variance equal to 1 will have a power spectrum equal to 1.
E 3
\item {\em IndL} : Optional output 1D IDL int array [Lmax+1]. Contains the multiplicative l(l+1) values.
\item {\em StdPS} : 1D IDL float array[Lmax+1]: estimated standard deviation of the $C_l$ coefficients.
\item {\em NormVal} : float, normalization value applied to the alm coefficients.
\item {\em alm} : IDL structure of ALM coefficients, result of the alm transform of the input image (see mrs\_almtrans) with options lmax, /tab, /psp, norm=? .
\item {\em PowSpecIma} : 2D IDL float array: Power spectrum of the input data for l and m.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item P = mrs\_powspec( Imag ) \\
Compute the power spectrum of the image.
\end{itemize}



\subsection{Wiener filtering of a map in spherical harmonics space : mrs\_wiener}
\index{IDL routines!mrs\_wiener}
\index{spherical harmonics!wiener filtering}
Perform wiener filtering of a map, in the spherical harmonic space, using the Healpix representation 
D 3
(nested data representation by default) or the GLESP representation. $Alm_output = Alm_input * WienerFilter$ where:
E 3
I 3
(nested data representation by default) or the GLESP representation. $Alm\_output = Alm\_input * WienerFilter$ where:
E 3
\[ WienerFilter =  \frac{ P^ * S}{ \mid P P^ * \mid^2 S + N } \]
with
\begin{itemize}
\item P, instrumental beam (i.e. PSF, by default P = 1)
\item S, a priori Signal Power Spectrum (default, power spectrum of the data)
\item N, Noise power spectrum
\end{itemize}
If the keyword ALM is set (it should be a structure (see mrs\_almtrans) containg the ALM coefficients of the datas, 
then the first parameter is not used and the alm are not calculated in this routine. The Wiener is optimal in the 
sens of the Least mean square error of the reconstructed map. The power spectrum of the reconstructed map is biased 
(i.e. $PowSpectrum(WienerMap) = \frac{PowSpectrum(RealMap)}{ (1 + N / (P^2S) ) }$). If the Cole keyword is set, then 
the Wiener filtering is replaced by the Cole filtering and the power spectrum of the reconstructed map is unbiased, 
but the estimation is not optimal anymore for the east mean square error criterion. The Cole filter is:
\[ ColeFilter =  \Big( \frac{S}{ ( \mid P P^* \mid^2 S + N ) } \Big)^{\frac{1}{2}} \]
If the keyword DataPrior is set, then the vector given by SignalPrior corresponds to an a priori on the power spectrum of the signal multiplied by $P^2$
{\bf
\begin{center}
D 3
     USAGE: mrs\_wiener, Imag, NoiseSpectrum, Recons, SignalPrior=SignalPrior, alm=alm, Spec1D=Spec1D, WienerFilter=WienerFilter, lmax=lmax, Psf=Psf, Cole=Cole, bias=bias
E 3
I 3
     USAGE: mrs\_wiener, Imag, NoiseSpectrum, Recons, alm=alm, lmax=lmax, SignalPrior=SignalPrior, Spec1D=Spec1D, WienerFilter=WienerFilter, Psf=Psf, Cole=Cole, bias=bias
E 3
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure, image to be denoised.
\item {\em NoiseSpectrum} : float or IDL 1D float array: variance or power spectrum of the noise.
\item {\em Recons} : Output IDL array of healpix map or Glesp image IDL structure, denoised image.
\item {\em SignalPrior} : Input IDL 1D float array, power spectrum of the expected signal. By default, it is estimated from the data.
\item {\em DataPrior} : scalar, if set the vector given by SignalPrior corresponds to an a priori on the power spectrum of the signal multiplied by $P^2$
\item {\em Psf} : Input IDL 1D float array, instrumental beam i.e. PSF[l] = Spherical Harmonics $a_{l,0} = \ldots = a_{l,l+1}$ of the intrumental beam (i.e. Point Spread Funciton).
\item {\em alm} : input/output ALM structure (see mrs\_almtrans). If this keyword is set, the input image 
is not used, and the ALM given by this keyword are used instead. The denoised ALM are stored in the structure.
{\bf ALM MUST have been calculated with the keywords "/tab" and "/norm" and not "/psp" or "/complex"} 
\item {\em Spec1D} : Output IDL 1D float array, estimated power spectrum of the denoised image.
\item {\em WienerFilter} : Output IDL 1D float array, Wiener filter.
\item {\em Lmax} : int, maximum l used in the calculation of the ALM. This kewyord is not used if the keyword ALM is set.
\item {\em Cole} : scalar, if set the Wiener filter is replaced by the Cole filter.
\item {\em bias} : Output float or IDL 1D float array, estimated bias on the power spectrum.
\end{itemize}



I 3

E 3
\section{Wavelets}
\index{wavelet}

\subsection{Mexican Hat Wavelet Transform : mrs\_wtmexhat}
\index{IDL routines!mrs\_wtmexhat}
\index{wavelet!mexican hat}
Convolves an input spherical map with the mexican hat wavelet function at a given scale.
{\bf
\begin{center}
     USAGE: Scale = mrs\_wtmexhat( Image, ScaleParameter )   
\end{center}}
where 
\begin{itemize}
\item {\em Image} : IDL array of Healpix map. Input image to be transformed 
\item {\em ScaleParameter} : float = Scale parameter  
\end{itemize}
\subsubsection*{Examples:} 
\begin{itemize}
D 3
\item coef = mrs\_wtmexhat( Image, sqrt(3.) / 3. ) \\
E 3
I 3
\item coef = mrs\_wtmexhat( Image, $\frac{\sqrt{3}}{3}$ ) \\
E 3
Convolve the data with a mexican hat wavelet function, with a scale parameter equal to $\frac{ \sqrt{3} }{3}$ 
which corresponds to an angular spread in $\theta$ of about $\frac{\pi}{6}$.
\end{itemize}



\subsection{bi-orthogonal wavelet transform : mrs\_owttrans}
\index{IDL routines!mrs\_owttrans}
\index{wavelet!bi-orthogonal wavelet transform}
\index{wavelet}
Computes the bi-orthogonal wavelet transform on the sphere with the filter bank 7/9 ($L_2$ normalization), using 
the HEALPix pixel representation (nested data representation). The wavelet transform is applied successively on 
the 12 faces of the Healpix image. The output is an IDL structure.
{\bf
\begin{center}
     USAGE: mrs\_owttrans, Imag, Trans, NbrScale=NbrScale, Opt=Opt  
\end{center}}
D 3
where 
E 3
I 3
where
E 3
\begin{itemize}
\item {\em Image} : Input IDL array of a Healpix map to be transformed. 
\item {\em Trans} : Output IDL structures with the following fields:
\begin{itemize}  
\item {\em NbrScale} : Number of scales of the wavelet transform.
\item {\em Coef} : 3D IDL array $[*,*,12]$ which contains the wavelet coefficients. $COEF[*,*, f]$ is the wavelet transform of the face $f$ ($f$=0..11).
\item {\em Nx} : int. number of pixels on the side of the Healpix patch, nside
\item {\em Ny} : int, same as Nx.	 
\end{itemize}
\item {\em NbrScale} : int, input optional parameter specifying the number of scales of the wavelet transform (default is 4)
\item {\em Opt} : string: if package MR1 is also installed, extra keyword used by mr\_transform.pro for the computation of the wavelet transform
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item  mrs\_owttrans, Imag, WT, NbrScale=5  \\
Compute the bi-orthogonal wavelet transform with five scales.
\item  tvscl, WT.coef[*,*,f] \\
plot the wavelet transform of the $\textrm{f}^{\textrm{th}}$ for $f \in \{0\ldots 11\}$.
\end{itemize}


\subsection{bi-orthogonal wavelet reconstruction : mrs\_owtrec}
\index{IDL routines!mrs\_owtrec}
\index{wavelet!bi-orthogonal wavelet reconstruction}
Reconstructs an image on the Sphere from its bi-orthogonal wavelet transform.   
 {\bf
\begin{center}
     USAGE: mrs\_owtrec, WT\_Struct, result  
\end{center}}
where 
\begin{itemize}
\item {\em WT\_Struct} : Input IDL structure Wavelet transform structure.
\item {\em Result} : Output 1D array of an Healpix image (nested format).
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item  mrs\_owttrans, Imag, WT, NbrScale=5 \\
Compute the bi-orthogonal wavelet transform with five scales.
\item  mrs\_owtrec, WT, RecIma \\
Wavelet reconstruction. 
\end{itemize}



\subsection{Undecimated Isotropic Wavelet Transform : mrs\_wttrans}
\index{IDL routines!mrs\_wttrans}
\index{wavelet!undecimated wavelet transform}
\index{wavelet}
Computes the undecimated isotropic wavelet transform on the sphere, using the Healpix pixel representation (nested data representation) or 
Glesp Data representation. The wavelet function is zonal and its spherical harmonics coefficients $a_{l,0}$ follow a cubic box-spline profile. 
If DifInSH is set, wavelet coefficients are derived in the Spherical Harmonic Space, otherwise (default) they are derived in the direct space.
{\bf
\begin{center}
D 3
     USAGE: mrs\_wttrans, Imag, Trans, NbrScale=NbrScale, lmax=lmax, DifInSH=DifInSH, MeyerWave=MeyerWave, Healpix\_with\_Glesp=Healpix\_with\_Glesp 
E 3
I 3
     USAGE: mrs\_wttrans, Imag, Trans, NbrScale=NbrScale, Healpix\_with\_Glesp=Healpix\_with\_Glesp, lmax=lmax, MeyerWave=MeyerWave, DifInSH=DifInSH
E 3
\end{center}}
where 
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure. Input image be transformed. 
\item {\em Trans} : Output IDL structures with the following fields:
\begin{itemize}
\item {\em NbrScale} : int, number of scales
\item {\em nside} : int, Healpix nside parameter (0 for a Glesp image)
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space
\item {\em npix} : long, Number of pixels of the input image
\item {\em Healpix\_with\_Glesp} : int, 1 if the keyword Healpix\_with\_Glesp used, otherwise 0
\item {\em UseGLESP} : int, 1 if the input image was in Glesp format, otherwise 0
\item {\em MeyerWave} : int, 1 if the keyword MeyerWave used, otherwise 0
\item {\em DifInSH} : int, 1 if the keyword DifInSH used, otherwise 0
\item {\em nx} : int, number of rings (Glesp parameter), otherwise, 0
\item {\em np} : int, max number of pixel on a ring (Glesp parameter), otherwise, 0
\item {\em x\_sky} : float array with COS( THETA ) for each ring (Glesp parameter), otherwise, 0
\item {\em y\_sky} : long array number of pixels/ring (Glesp parameter), otherwise, 0
D 3
\item {\em Coef} : fltarr[npix,NbrScale] wavelet transform of the data
E 3
I 3
\item {\em Coef} : fltarr[ npix, NbrScale ] wavelet transform of the data
E 3
\begin{center}
D 3
Coef[*,0] = wavelet coefficients of the finest scale (highest frequencies).\\
Coef[*,NbrScale-1] = coarsest scale (lowest frequencies). 
E 3
I 3
Coef[ *, 0 ] = wavelet coefficients of the finest scale (highest frequencies).\\
Coef[ *, NbrScale-1 ] = coarsest scale (lowest frequencies). 
E 3
\end{center}
\end{itemize}
\item {\em NbrScale} : int, optional input parameter specifying the number of scales (default is 4).
\item {\em Lmax} : int, optional input parameter specifying the maximum multipole number $l$ in the spherical harmonics decomposition 
(default is $3\times \textrm{nside}$, should be between $2\times \textrm{nside}$ and $4\times \textrm{nside}$).
\item {\em DifInSH} : Input keyword parameter. If set, the wavelet coefficients are computed as the difference between two resolutions in the spherical harmonics representation. 
Otherwise, the wavelet coefficients are computed as the difference between two resolutions in direct space.
\item {\em MeyerWave} : If set, use Meyer wavelets and set the keyword DifInSH.
\item {\em Healpix\_with\_Glesp} : If set, a copy of Imag is done in Glesp format in order to compute the wavelet transform.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_wttrans, Imag, Trans, NbrScale=5 \\
Undecimated Wavelet transform with five scales.
\item tvs, Trans.coef[*,0]  \\
Visualization of the first scale.
\end{itemize}


\subsection{Undecimated Isotropic Wavelet Reconstruction : mrs\_wtrec}
\index{IDL routines!mrs\_wtrec}
\index{wavelet!undecimated wavelet reconstruction}
Reconstructs an image on the sphere from its wavelet coefficients obtained with the undecimated isotropic wavelet transform on the sphere, described right above.
{\bf
\begin{center}
     USAGE: mrs\_wtrec, Trans, Rec, filter=filter 
\end{center}}
where 
\begin{itemize}
\item {\em Trans}: input IDL structures with the following fields:  
\begin{itemize}
\item {\em NbrScale} : int, number of scales 
\item {\em nside} : int, Healpix nside parameter (0 for a Glesp image)
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space
\item {\em npix} : long, Number of pixels of the input image
\item {\em Healpix\_with\_Glesp} : int, 1 if the keyword Healpix\_with\_Glesp used at the transformation, otherwise 0
\item {\em UseGLESP} : int, 1 if the input image was in Glesp format, otherwise 0
\item {\em MeyerWave} : int, 1 if the keyword MeyerWave used, otherwise 0
\item {\em DifInSH} : int, 1 if the keyword DifInSH used, otherwise 0
\item {\em nx} : int, number of rings (Glesp parameter), otherwise, 0
\item {\em np} : int, max number of pixel on a ring (Glesp parameter), otherwise, 0
\item {\em x\_sky} : float array with COS( THETA ) for each ring (Glesp parameter), otherwise, 0
\item {\em y\_sky} : long array number of pixels/ring (Glesp parameter), otherwise, 0
D 3
\item {\em Coef} : fltarr[npix,NbrScale] wavelet transform of the data
E 3
I 3
\item {\em Coef} : fltarr[ npix, NbrScale ] wavelet transform of the data
E 3
\begin{center}
D 3
Coef[*,0] = wavelet coefficients of the finest scale (highest frequencies).\\
Coef[*,NbrScale-1] = coarsest scale (lowest frequencies). 
E 3
I 3
Coef[ *, 0 ] = wavelet coefficients of the finest scale (highest frequencies).\\
Coef[ *, NbrScale-1 ] = coarsest scale (lowest frequencies). 
E 3
\end{center} 
\end{itemize}
\item {\em Rec} : Output IDL array of healpix map: reconstructed image from the wavelet coefficients or Glesp image IDL structure if UseGlesp=1. 
\item {\em filter} : Input keyword parameter. Use filters for the reconstructions. If this keyword is not set, the reconstructed image is obtained 
by a simple addition of all wavelet scales. Automaticaly applied if keyword MeyerWave or DifInSH were set at the wavelet decomposition.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_wttrans, Imag, Trans, NbrScale=5 \\
Undecimated Wavelet transform with five scales.
\item mrs\_wtrec, Trans, RecIma \\
Reconstruction of the image from its wavelet coefficients.
\end{itemize}



\subsection{Undecimated Isotropic Wavelet Packet Transform : mrs\_wptrans}
\index{IDL routines!mrs\_wptrans}
\index{wavelet!undecimated wavelet packet transform}
\index{wavelet}
Computes the undecimated isotropic wavelet packet transform on the sphere with meyer wavelets, 
using the Healpix representation (nested data representation) or the Glesp representation.
{\bf
\begin{center}
     USAGE: mrs\_wptrans, Imag, Trans, NbrScale=NbrScale
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure. Input image be transformed. 
\item {\em Trans} : Output IDL structures with the following fields:
\begin{itemize}
\item {\em NbrScale} : int, number of scales
\item {\em nside} : int, Healpix nside parameter (0 for a Glesp image)
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space
\item {\em npix} : long, Number of pixels of the input image
\item {\em UseGLESP} : int, 1 if the input image was in Glesp format, otherwise 0
\item {\em nx} : int, number of rings (Glesp parameter), otherwise, 0
\item {\em np} : int, max number of pixel on a ring (Glesp parameter), otherwise, 0
\item {\em x\_sky} : float array with COS( THETA ) for each ring (Glesp parameter), otherwise, 0
\item {\em y\_sky} : long array number of pixels/ring (Glesp parameter), otherwise, 0
D 3
\item {\em Coef} : fltarr[npix,NbrScale] wavelet transform of the data
E 3
I 3
\item {\em Coef} : fltarr[ npix, NbrScale ] wavelet transform of the data
E 3
\end{itemize}
\item {\em NbrScale} : int, optional output parameter specifying the number of scales.
\item {\bf The image reconstruction is done by using the procedure mrs\_wtrec}
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_wptrans, Imag, Trans \\
Undecimated Wavelet Packet transform.
\item  mrs\_wtrec, Trans, RecIma \\
Reconstruction of the image from its wavelet coefficients.
\end{itemize}



\subsection{Undecimated Wavelet Transform with "A Trou" Algorithm : mrs\_attrans}
\index{IDL routines!mrs\_attrans}
\index{wavelet!undecimated wavelet transform}
\index{wavelet}
Compute the isotropic wavelet transform on the sphere, using the Healpix pixel representation (nested data representation) 
and using the "A TROU" algorithm. The wavelet transform is applied successively on the  12 faces of the Healpix image. 
The output is a IDL structure.
{\bf
\begin{center}
     USAGE: mrs\_attrans, Imag, Trans, NbrScale=NbrScale, Opt=Opt, modif=modif, healpix=healpix
\end{center}}
where
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or Glesp image IDL structure. Input image be transformed. 
\item {\em Trans} : Output IDL structures with the following fields:  
\begin{itemize}
\item {\em NbrScale} : int, number of scales of the wavelet transform.
\item {\em Coef} : 4D IDL float array [*,*,*,12] : Wavelet coefficients cube containing all wavelet coefficients.
\begin{center}
Coef[ x, y, j, f ] = wavelet coefficients at face f (f=0..11), position x, y and scale j
\end{center}
\item {\em Nx} : int, number of pixels on the side of the Healpix patch, nside
\item {\em Ny} : int, same as Nx	
\end{itemize}
\item {\em NbrScale} : int, number of scales of the wavelet transform, default is 4
\item {\em Opt} : string, if package MR1 is installed, extra keyword used by mr\_transform.pro
\item {\em modif} : scalar, if set, add extra smoothing with spline filtering
\item {\em healpix} : scalar, if set, change ATTrans.coef to a 2D array [ c, j ] by reordering wavelet coefficients at scale j as a Healpix NESTED map.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_attrans, Imag, WT, NbrScale=5 \\
Undecimated Wavelet transform with five scales and "A TROU" algorithm.
\item  tvscl, WT.coef[*,*,0,f] \\
Plot the fth face of the first scale of the wavelet transform.
\end{itemize}


\subsection{Undecimated Wavelet Transform with "A Trou" Algorithm reconstruction : mrs\_atrec}
\index{IDL routines!mrs\_atrec}
\index{wavelet!undecimated wavelet transform}
\index{wavelet}
Reconstructs an image on the sphere from its wavelet coefficients obtained with the undecimated wavelet 
transform on the sphere with the "A TROU" algorithm, described right above.
{\bf
\begin{center}
     USAGE: mrs\_atrec, Trans, Rec
\end{center}}
where 
\begin{itemize}
\item {\em Trans}: input IDL structures with the following fields:  
\begin{itemize}
\item {\em NbrScale} : int, number of scales of the wavelet transform.
\item {\em Coef} : 4D IDL float array [*,*,*,12] : Wavelet coefficients cube containing all wavelet coefficients.
\begin{center}
Coef[ x, y, j, f ] = wavelet coefficients at face f (f=0..11), position x, y and scale j
\end{center}
\item {\em Nx} : int, number of pixels on the side of the Healpix patch, nside
\item {\em Ny} : int, same as Nx
\end{itemize}
\item {\em Rec} : Output IDL array of healpix map in nested format: reconstructed image from the wavelet coefficients. 
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_attrans, Imag, Trans, NbrScale=5 \\
Undecimated Wavelet transform with five scales.
\item  mrs\_atrec, Trans, RecIma \\
Reconstruction of the image from its wavelet coefficients.
\end{itemize}



\subsection{Pyramidal Wavelet Transform : mrs\_pwttrans}
\index{IDL routines!mrs\_pwttrans}
\index{wavelet!pyramidal wavelet transform}
\index{wavelet}
Computes the pyramidal wavelet transform on the sphere, using the Healpix pixel representation (nested data representation) or Glesp Data representation. 
The wavelet function is zonal and its spherical harmonics coefficients $a_{l,0}$ follow a cubic box-spline profile. 
{\bf
\begin{center}
     USAGE: mrs\_pwttrans, Imag, Trans, NbrScale=NbrScale, lmax=lmax, DifInSH=DifInSH, MeyerWave=MeyerWave 
\end{center}}
where 
\begin{itemize}
\item {\em Imag} : Input IDL array of Healpix map or IDL structure of a Glesp map. Input image be transformed. 
\item {\em Trans} : Output IDL structures with the following fields:   
\begin{itemize}
\item {\em UseGLESP} : int, 1 if the input image was in Glesp format, otherwise 0
\item {\em NbrScale} : int, number of scales 
\item {\em nside} : int, Healpix nside parameter, only present with healpix input image
\item {\em npix} : long, Number of pixels of the input image
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space at the first scale
\item {\em Tab\_lmax} : int array Tab\_lmax[j], lmax at scale j+1, j=0..NbrScale-1
\item {\em Tab\_nside} : int array Tab\_nside[j], nside parameter of the scale j+1, j=0..NbrScale-1 (Healpix input map) 
or nx number of rings, Glesp parameter of the scale j+1, j=0..NbrScale-1 (Glesp input map)
\item {\em nx} : int, number of rings at the first scale, Glesp parameter, only present with glesp input image
\item {\em np} : int, max number of pixel on a ring at the first scale, Glesp parameter, only present with glesp input image
\item {\em Scalej} : j th scale (j=1..NbrScale), j = 1 is the finest scale (highest frequencies), 
with j = NbrScale, coarsest resolution. A IDL array of healpix map or IDL structure of a Glesp map
\item {\em MeyerWave} : int = 1 if the keyword MeyerWave used, otherwise 0
\item {\em DifInSH} : int = 1 if the keyword DifInSH used, otherwise 0
\end{itemize}
\item {\em NbrScale} : Optional input parameter specifying the number of scales in the decomposition (default is 4).
\item {\em lmax} : Optional input parameter specifying the maximum multipole number $l$ in the spherical harmonics decomposition 
(default is $3\times \textrm{nside}$, should be between $2\times \textrm{nside}$ and $4\times \textrm{nside}$).
\item {\em DifInSH} : Compute be difference between two resolution in the spherical harmonic space instead of the direct space.
\item {\em MeyerWave} : If set, use Meyer wavelets and set the keyword DifInSH 
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_pwttrans, Imag, Trans, NbrScale=5 \\
Pyramidal Wavelet transform with five scales.
\item  tvs, Trans.Scale1  \\
Visualization of the first scale.
\end{itemize}



\subsection{Pyramidal Wavelet Reconstruction : mrs\_pwtrec}
\index{IDL routines!mrs\_pwtrec}
\index{wavelet!pyramidal wavelet reconstruction}
Computes the inverse pyramidal wavelet transform on the sphere.
{\bf
\begin{center}
     USAGE: mrs\_pwtrec, Trans, Rec, filter=filter 
\end{center}}
where 
\begin{itemize}
\item {\em Trans} : Input IDL structures with the following fields:  
\begin{itemize}
\item {\em UseGLESP} : int, 1 if the input image was in Glesp format, otherwise 0
\item {\em NbrScale} : int, number of scales 
\item {\em nside} : int, Healpix nside parameter, only present with healpix input image
\item {\em npix} : long, Number of pixels of the input image
\item {\em lmax} : int, maximum l value in the Spherical Harmonic Space at the first scale
\item {\em Tab\_lmax} : int array Tab\_lmax[j], lmax at scale j+1, j=0..NbrScale-1
\item {\em Tab\_nside} : int array Tab\_nside[j], nside parameter of the scale j+1, j=0..NbrScale-1 (Healpix input map) 
or nx number of rings, Glesp parameter of the scale j+1, j=0..NbrScale-1 (Glesp input map)
\item {\em nx} : int, number of rings at the first scale, Glesp parameter, only present with glesp input image
\item {\em np} : int, max number of pixel on a ring at the first scale, Glesp parameter, only present with glesp input image
\item {\em Scalej} : j th scale (j=1..NbrScale), j = 1 is the finest scale (highest frequencies), 
with j = NbrScale, coarsest resolution. A IDL array of healpix map or IDL structure of a Glesp map
\item {\em MeyerWave} : int = 1 if the keyword MeyerWave used, otherwise 0
\item {\em DifInSH} : int = 1 if the keyword DifInSH used, otherwise 0
\end{itemize}
\item {\em Rec} : IDL array of Healpix map or IDL structure of a Glesp map. Output reconstructed image.  
\item {\em filter} : Optional inout keyword. If set, conjugate filters are used in the reconstruction. Otherwise, the reconstructed 
image is obtained by a simple interpolation/addition of all wavelet scales. When computing direct transform (mrs\_pwttrans function), 
if the keywords DifInSH or MeyerWave were setted, filter is automatically used.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_pwttrans, Imag, Trans, NbrScale=5 \\
Pyramidal Wavelet transform with five scales.
\item  mrs\_pwtrec, Trans, RecIma  \\
Reconstruction of the image from its wavelet coefficients.
\end{itemize}



\subsection{Extract a Wavelet Scale : mrs\_wtget}
\index{IDL routines!mrs\_wtget}
Returns a scale of the wavelet transform obtained by the command {\em mrs\_wttrans} or by the command {\em mrs\_pwttrans}.
 {\bf
\begin{center}
     USAGE:   Scale = mrs\_wtget( Trans, ScaleNumber, Face=Face, NormVal=NormVal )
\end{center}}
where 
\begin{itemize}
\item {\em Trans} : Input IDL structure containing the wavelet transform.  
\item {\em ScaleNumber} : integer scale number. The scale number must be between 0 and Trans.NbrScale-1
\item {\em Face} : optional input keyword parameter. If set, the routine returns a Cube[*,*,0:11] containing the twelve faces of the HEALPix representation.
\item {\em NormVal} : float, normalization coefficient in that band. 
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_pwttrans, Imag, Trans, NbrScale=5 \\
Pyramidal Wavelet transform with five scales.
\item  Band1 = mrs\_wtget(Trans,0) \\
Extract the first wavelet scale.
\end{itemize}



\subsection{Insert a band into  Wavelet Transform : mrs\_wtput}
\index{IDL routines!mrs\_wtput}
Replaces a map of coefficients at a given scale in the wavelet transform obtained by the command {\em mrs\_wttrans} or by the command {\em mrs\_pwttrans}.
 {\bf
\begin{center}
     USAGE:  mrs\_wtput, Trans, Scale, ScaleNumber, Face=Face 
\end{center}}
where 
\begin{itemize}
\item {\em Trans} : Input IDL structure containing the wavelet transform. 
\item {\em Scale} : IDL array, the wavelet scale we want to insert in the specified decomposition.
\item {\em ScaleNumber} : integer. Specifies the scale number to be replaced by the given Scale map. The scale number must be between 0 and $\textrm{Trans.NbrScale}-1$.
\item {\em Face} : If set, the routine put into Trans a Cube[*,*,0:11] containing the twelve faces of the HEALPix representation
\item {\em NormVal} : float: Normalization value of the band. 
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_pwttrans, Imag, Trans, NbrScale=5 \\
Pyramidal Wavelet transform with five scales.
\item Band1 = mrs\_wtget( Trans, 0 ) \\
Extract the first wavelet scale.
\item Band1\_thres = mrs\_absthreshold( Band1, mrs\_sigma( Band1 ) ) \\
Hard thresholding of the scale.
\item mrs\_wtput( Trans, Band1\_thres, 0 ) \\
Insert the new wavelet scale.
\end{itemize}



\subsection{Visualization of the wavelet scales : mrs\_wttv}
\index{IDL routines!mrs\_wttv}
\index{wavelet!visualization}
Visualization of the wavelet transform obtained by the command {\em mrs\_wttrans} or by the command {\em mrs\_pwttrans}. 
If the keyword WRITE is set to a string, then all the scales are written on the disk as PNG files, and the string is used 
as a prefix for the file name of the different scales.
{\bf
\begin{center}
     USAGE:  mrs\_wttv, Trans, Tit=Tit, write=write, graticule=graticule, min=min, max=max, big=big
\end{center}}
where
\begin{itemize}
\item {\em Trans} : Input IDL structure containing the wavelet transform.
\item {\em Tit} : string: Title of the plot.
\item {\em write} : string: Prefix filename. If set, write to disk each scale of the wavelet transform in PNG format.
\item {\em graticule} : this is the GRATICULE keyword in the HEALPix command MOLLVIEW.
\item {\em min} : float Mollview Healpix command min, new min value to be used for the display.
\item {\em max} : float Mollview Healpix command max, new max value to be used for the display.
\item {\em big} : bool if set, Mollview Healpix keyword pxsize is set to 1500
\end{itemize}
\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_pwttrans, Imag, Trans, NbrScale=5 \\
Pyramidal  Wavelet transform with five scales.
\item mrs\_wttv, Trans \\
Visualization of all scales.
\end{itemize}



\subsection{Wavelet filtering : mrs\_wtfilter}
\index{IDL routines!mrs\_wtfilter}
\index{wavelet!filtering}
\index{wavelet}
Wavelet denoising of an image on the sphere (Healpix pixel nested representation) or Glesp Data representation. By default, 
the noise is assumed to follow a Gaussian distribution. If the keyword SigmaNoise is not set, then the noise standard deviation 
is automatically estimated. If the keyword MAD is set, then a correlated Gaussian noise is considered, and the noise level at 
each scale is derived from the Median Absolution Deviation (MAD) method. If the keyword KillLastScale is set, the coarsest 
resolution is set to zero. If the "Pyr" keyword is used, then the pyramidal WT is used instead of the undecimated WT. 
If the "atrou" keyword is used, then the "a trou" WT is used instead of the undecimated WT. If the keyword CYCLE is set, 
D 3
the denoising is performed three times, by shifting the data by PI/4 and -PI/4, denoising the shifted version, and averaging 
E 3
I 3
the denoising is performed three times, by shifting the data by $\pi/4$ and $-\pi/4$, denoising the shifted version, and averaging 
E 3
the unshifted denoising maps. This procedure allows us to remove the block effect which may appear on the border of the Healpix faces. 
The thresholded wavelet coefficients can be obtained using the keyword Trans. If the input keyword NITER is set, then an iterative 
algorithm is applied and if the POS keyword is also set, then a positivity constraint is added.
{\bf
\begin{center}
D 3
     USAGE:  mrs\_wtfilter, Imag, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, lmax=lmax, TabNSigma=TabNSigma, mad=mad, 
     localmad=localmad, WinMinSize=WinMinSize, KillLastScale=KillLastScale, Trans=Trans, Pyr=Pyr, niter=niter, pos=pos, cycle=cycle, 
     FirstScale=FirstScale, Soft=Soft, fdr=fdr, Use\_FdrAll=Use\_FdrAll, FilterLast=FilterLast, mask=mask, atrou=atrou, OutMask=OutMask 
E 3
I 3
     USAGE: mrs\_wtfilter, Imag, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, lmax=lmax, TabNSigma=TabNSigma, mad=mad, 
     localmad=localmad, WinMinSize=WinMinSize, Soft=Soft, niter=niter, pos=pos, Pyr=Pyr, cycle=cycle, Trans=Trans, KillLastScale=KillLastScale, 
     FirstScale=FirstScale, fdr=fdr, Use\_FdrAll=Use\_FdrAll, mask=mask, FilterLast=FilterLast, atrou=atrou, OutMask=OutMask 
E 3
\end{center}}
where
\begin{itemize}
\item {\em Image} : Input IDL Healpix array or Glesp IDL structure containing the input map.
\item {\em Filter} : Output IDL Healpix array or Glesp IDL structure containing the output filtered map.
\item {\em NbrScale} : int = Number of scales (default is 4).
\item {\em NSigma} : float = Level of thresholding (default is 3).
\item {\em TabNSigma} : float array = Level of thresholding at each scale
\item {\em SigmaNoise} : float = Noise standard deviation. Default is automatically estimated.
\item {\em mad} : if set, then the noise level is derive at each scale using the MAD of the wavelet coefficient. MAD = median ( ABS( WaveletScale) ) / 0.6745.
\item {\em localmad} : int if set, similar to keyword MAD but with one value for each patch of the image and each instead of one value for the full image at each scale.
\item {\em WinMinSize} : int minimal size of patches (default is 8).
\item {\em KillLastScale} : if set, the last scale is set to zero.
\item {\em niter} : number of iterations used in the reconstruction.
\item {\em pos} : if set, the solution is assumed to be positive.
\item {\em Pyr} : if set, a pyramidal WT is used instead of the the undecimated WT.
\item {\em cycle} : int: if set, then a cycle spanning is applied.
\item {\em FirstScale} : int: Consider only scales larger than FirstScale. Default is 1 (i.e. all scales are used).
\item {\em Soft} : if set, use soft thresholding instead of hard thresholding.
\item {\em fdr} : float between 0 (default) and 1 (max, if greater or equal to 1, set to 0.05), used to estimate a threshold level 
instead of a NSigma threshold, threshold is applied from scale j=FirstScale to the last.
\item {\em Use\_FdrAll} : same as fdr but applied to all scales.
\item {\em FilterLast} : if set, the last scale is filtered.
\item {\em mask} : IDL array of healpix map, input mask applied.
\item {\em lmax} : int = maximum l value in the Spherical Harmonic Space.
\item {\em atrou} : if set, a "a trou" WT is used instead of the the undecimated WT.
\item {\em Trans} : IDL structure: Thresholded wavelet decomposition of the input image.
\item {\em OutMask} : IDL array of healpix map, part of Imag that were set to 0 via the filtering, including keyword mask if used.
\item {\bf localmad, cycle and atrou keywords don't work with Glesp images, an error will be generated}
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_wtfilter, Imag, Filter, NbrScale=5 \\
Wavelet filtering with five scales.
\item mrs\_wtfilter, Imag, Filter, NbrScale=5, Nsigma=5 \\
Ditto, but using a 5 sigma threshold.
\end{itemize}



\section{Ridgelet}

\subsection{Ridgelet transform : mrs\_ridtrans}
\index{IDL routines!mrs\_ridtrans}
\index{ridgelet!transform}
\index{ridgelet}
Compute the ridgelet transform on the sphere using the Healpix pixel representation (nested data representation). The standard ridgelet transform 
D 3
is applied on the 12 faces of the Healpix image. The output is an IDL structure. A band at scale $j$ ($j=0..NBRSCALE-1$) can be extracted using 
the function {\em mrs\_ridget(Rid, j)} (\emph{e.g.} Scale2 = mrs\_ridget(RidTrans, 2)) and a band can be inserted in the transformation using 
the routine {\em mrs\_ridput} (\emph{e.g.}  mrs\_ridput, RidTrans, Scale2, 2).
E 3
I 3
is applied on the 12 faces of the Healpix image. The output is an IDL structure. A band at scale $j$ ($j=0\ldots$NBRSCALE$-1$) can be extracted using 
the function {\em mrs\_ridget(Rid, j)} (e.g. Scale2 = mrs\_ridget(RidTrans, 2)) and a band can be inserted in the transformation using 
the routine {\em mrs\_ridput} (e.g. mrs\_ridput, RidTrans, Scale2, 2).
E 3
{\bf
\begin{center}
D 3
     USAGE:  mrs\_ridtrans, Imag, RidTrans, NbrScale=NbrScale, overlap=overlap, blocksize=blocksize, Opt=Opt 
E 3
I 3
     USAGE: mrs\_ridtrans, Imag, RidTrans, NbrScale=NbrScale, overlap=overlap, blocksize=blocksize, Opt=Opt 
E 3
\end{center}}
where
\begin{itemize}
\item {\em Image} : Input IDL HEALPix array containing the input map.
\item {\em RidTrans} : Output IDL structure with the following fields: 
\begin{itemize} 
\item {\em NbrScale} : long, Number of scales of the ridgelet transform.
\item {\em Coef} : Ridgelet coefficients. If MR1 package is installed, it is a 3D IDL array [*,*,12] containing all ridgelet coefficients. 
If MR1 package is not installed, it is a IDL array of 12 structures (one for each Healpix face).
\item {\em Bsize} : long, Block size used in the ridgelet transform.
\item {\em nxb} : long, Number of blocks in the x-axis direction.
\item {\em nyb} : long, Number of blocks in the y-axis direction.
\item {\em Overlap} : long, is equal to 1 if blocks are overlapping.
D 3
\item {\em TabNorm} : float Array[0:NBRSCALE-1]: Normalization value for each scale.
E 3
I 3
\item {\em TabNorm} : float Array[ 0 : NBRSCALE-1 ]: Normalization value for each scale.
E 3
\end{itemize}
\item {\em NbrScale} : int, number of scales in the ridgelet decomposition. By default it is automatically estimated.
\item {\em Overlap} : if this keyword is set, the blocks in the local ridgelet transform overlap by half their size, otherelse the blocks do not overlap.
\item {\em Blocksize} : long, this is the size of the square blocks on which the local ridgelet transform is computed. 
If not set, then the blocksize is taken to be half the size of the individaul faces ie blocksize = nside/2. Blocksize is 
required to be a power of two smaller than nside which is also a power of two. There is no testing of this requirement.
\item {\em Opt} : string, sets options to used if the mre package is available. If mre is not available, 
then Opt is useless, and only procedures in mrs are used.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_ridtrans, Imag, Rid   \\
Compute the ridgelet transform
\item mrs\_ridtrans, Imag, Rid, /overlap, blocksize=32 \\
Ditto, but using a overlapping blocks of size 32.
\end{itemize}



\subsection{Ridgelet reconstruction : mrs\_ridrec}
\index{IDL routines!mrs\_ridrec}
\index{ridgelet!reconstruction}
Reconstructs an image on the Sphere from its ridgelet transform (see mrs\_ridtrans).   
{\bf
\begin{center}
D 3
     USAGE:  mrs\_ridrec, Rid\_Struct, Result 
E 3
I 3
     USAGE: mrs\_ridrec, Rid\_Struct, Result 
E 3
\end{center}}
where
\begin{itemize}
\item {\em Rid\_Struct} : Input IDL structure, Ridgelet transform structure (see mrs\_ridtrans).
\item {\em Result} : Output 1D array of an Healpix image (nested format).
\end{itemize}
\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_ridtrans, Imag, Rid   \\
Compute the ridgelet transform
\item mrs\_ridrec, Rid, RecIma \\
Ridgelet reconstruction.
\end{itemize}



\subsection{Extract a ridgelet band : mrs\_ridget}
\index{IDL routines!mrs\_ridget}
Extracts a ridgelet band from the ridgelet transform (see mrs\_ridtrans). A specific normalization can be applied 
to the local ridgelet coefficients. Indeed, after applying the ridgelet transform to all blocks, we obtain a set of 
$n_b$ blocks $R_i(a,b,\theta)$ ($i=1 \dots n_b$), and for each scale, orientation and position $(a,b,\theta)$, 
we extract the vector $V_{a,b,\theta}(i)$. Then the normalization consists in dividing the ridgelet coefficients 
D 3
$R_i(a,b,\theta)$ ($i=1..n_b$) by their $\mathrm{MAD}$ value (Median Absolution Deviation) defined by $\mathrm{MAD} = \mathrm{median}(\mid x \mid )/0.6745$ \cite{astro:mad93}. 
E 3
I 3
$R_i(a,b,\theta)$ ($i=1..n_b$) by their $\mathrm{MAD}$ value (Median Absolution Deviation) defined by $\mathrm{MAD} = \mathrm{median}(\mid x \mid )/0.6745$ \citep{astro:mad93}. 
E 3
Hence, we normalize the ridgelet coefficients by the following expression:
\begin{eqnarray}
D 3
\bar{R}_i(a,b,\theta) = \frac{R_i(a,b,\theta)}{\mathrm{MAD}(V_{a,b,\theta})}.
E 3
I 3
\bar{R}_i(a,b,\theta) = \frac{R_i(a,b,\theta)}{\mathrm{MAD}(V_{a,b,\theta})}
E 3
\end{eqnarray}
If the keyword NormMad is set, the normalization is applied.

{\bf
\begin{center}
D 3
     Result = mrs\_ridget( Rid\_Struct, ScaleRid, NormMad=NormMad, ImaMean=ImaMean, ImaMad=ImaMad ) 
E 3
I 3
     USAGE: Result = mrs\_ridget( Rid\_Struct, ScaleRid, NormMad=NormMad, ImaMean=ImaMean, ImaMad=ImaMad ) 
E 3
\end{center}}
where
\begin{itemize}
\item {\em Rid\_Struct} : Input IDL structure. Ridgelet transform structure (see mrs\_ridtrans).
\item {\em ScaleRid} : int, input Ridgelet band number.
\item {\em NormMad} : scalar, if set, normalize the coefficients by the Median Absolution Deviation of all coefficients at a give position in the block.
\item {\em ImaMean} : 2D IDL float array: Image containing the mean value for all coefficients at a given position in the block.
\item {\em ImaMad} : 2D IDL float array: Image containing  the normalization parameters.
\item {\em Result} : 4D IDL float array[*,*,*,12], output extracted band.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_ridtrans, Imag, Rid   \\
Compute the ridgelet transform
\item Band = mrs\_ridrec(Rid,0) \\
Extract the first scale.
\end{itemize}



\subsection{Insert a band into Ridgelet Transform : mrs\_ridput}
\index{IDL routines!mrs\_ridput}
Insert a band in the ridgelet transform (see mrs\_ridtrans).   
{\bf
\begin{center}
D 3
      mrs\_ridput, Rid\_Struct, Band, ScaleRid
E 3
I 3
      USAGE: mrs\_ridput, Rid\_Struct, Band, ScaleRid
E 3
\end{center}}
where
\begin{itemize}
\item {\em Rid\_Struct} : Input/Output IDL structure. Ridgelet transform structure (see mrs\_ridtrans).
\item {\em Band} : IDL 4D array: input band to insert in the ridgelet transform.
\item {\em ScaleRid} : int, input Ridgelet band number.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_ridtrans, Imag, Rid   \\
Compute the ridgelet transform
\item Band = mrs\_ridget(Rid,0) \\
Extract the first scale.
\item Band[*] = 0
Set the band to zero.
\item mrs\_ridput, Rid\_Struct, Band,  0 \\
Reinsert the modified band.  
\end{itemize}

\section{Curvelet}

\subsection{Curvelet transform : mrs\_curtrans}
\index{IDL routines!mrs\_curtrans}
\index{curvelet!transform}
\index{curvelet}
Computes the curvelet transform on the sphere, using the Healpix pixel representation (nested data representation). 
A band of the curvelet transform is defined by two number, the 2D WT scale number and the ridgelet scale number. 
D 3
The output is an IDL structure. A band at wavelet scale $j$ ($j$=0..NBRSCALE-1) and ridgelet scale $j_1$ can be 
E 3
I 3
The output is an IDL structure. A band at wavelet scale $j$ ($j$=0...NBRSCALE-1) and ridgelet scale $j_1$ can be 
E 3
extracted using the function mrs\_curget(Curtrans, $j$, $j_1$) (ex: Scale2\_1 = mrs\_curget(CurTrans, 2, 1)) and 
a band can be inserted in the transformation using the routine mrs\_curput (ex: mrs\_curput, CurTrans, Scale2\_1, 2, 1). 
By default, the pyramidal curvelet is applied. If the keyword UNDEC is set, then the standard undecimated curvelet transform is applied.
{\bf
\begin{center}
D 3
       mrs\_curtrans, Imag, CurTrans, Opt=Opt, lmax=lmax, NbrScale=NbrScale, Overlap=Overlap, Undec=Undec, FirstBlockSize=FirstBlockSize, Silent=Silent
E 3
I 3
      USAGE: mrs\_curtrans, Imag, CurTrans, Opt=Opt, lmax=lmax, NbrScale=NbrScale, Overlap=Overlap, Undec=Undec, FirstBlockSize=FirstBlockSize, Silent=Silent
E 3
\end{center}}
where
\begin{itemize}
\item {\em Image} : Input IDL Healpix array of the map to be transformed.
\item {\em RidTrans} : Output IDL structure with the following fields: 
\begin{itemize} 
\item {\em NbrScale} : int, Number of scales of the ridgelet transform.
D 3
\item {\em TabBlockSize} : int array TABBLOCKSIZE[j], Block size in the ridgelet transform at scale j, j = 0..NBRSCALE-1.
E 3
I 3
\item {\em TabBlockSize} : int array TABBLOCKSIZE[j], Block size in the ridgelet transform at scale j, j = 0...NBRSCALE-1.
E 3
\item {\em TabNbrScaleRID} : int array TABNBRSCALERID[j], number of ridgelet band at scale j.
\item {\em TabNorm} : 2D IDL array : Normalization array.
\item {\em RidScale1} : IDL structure : ridgelet transform of the first wavelet scale (see mrs\_ridtrans for details).
D 3
\item {\em RidScalej} : IDL structure : ridgelet transform of the jth wavelet scale, j = 1..NBRSCALE-1.
E 3
I 3
\item {\em RidScalej} : IDL structure : ridgelet transform of the $j^{\textrm{th}}$ wavelet scale,\\ $j=1\ldots$NBRSCALE-1.
E 3
\item {\em LastScale} : 1D IDL float array: Healpix image of the coarsest scale.
\item {\em WT} : IDL structure: Wavelet structure (for internal use only).
\item {\em PyrTrans} : int, equal to 1 for a pyramidal curvelet transform and 0 otherwise .
\end{itemize}
\item {\em NbrScale} : int, Number of scales in the 2D wavelet transform (default 4).
\item {\em Undec} : int, if set, an undecimated curvelet transform is used instead of the pyramidal curvelet transform.
\item {\em FirstBlockSize} : int Block size in the ridgelet transform at the finest scale (default value is 16).
\item {\em Lmax} : int, Number of used spherical harmoniques used in the wavelet transform 
(default is $3\times \textrm{nside}$, should be between $2\times \textrm{nside}$ and $4\times \textrm{nside}$).
\item {\em Overlap} : int, if set blocks in the internal ridgelet transform are overlapping.
\item {\em Opt} : string, optionnal parameters used by mrs\_ridtrans (see mrs\_ridtrans).
\item {\em Silent} : scalar, if set, verbose mode disabled
\end{itemize}

\subsubsection*{Example:} 
\begin{itemize}
\item mrs\_curtrans, Imag, Cur \\
Compute the curvelet transform
\end{itemize}



\subsection{Curvelet reconstruction : mrs\_currec}
\index{IDL routines!mrs\_currec}
\index{curvelet!reconstruction}
Reconstructs an image on the Sphere from its curvelet transform (see mrs\_curtrans).   
{\bf
\begin{center}
D 3
       mrs\_currec, Cur\_Struct, result  
E 3
I 3
      USAGE: mrs\_currec, Cur\_Struct, result  
E 3
\end{center}}
where
\begin{itemize}
\item {\em Cur\_Struct} : Input IDL structure, Curvelet transform structure (see mrs\_curtrans).
\item {\em Result} : Output 1D IDL array of the reconstructed Healpix image (nested format).
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_curtrans, Imag, Cur   \\
Compute the curvelet transform
\item mrs\_currec,  Cur, RecIma \\
Curvelet reconstruction.
\end{itemize}



\subsection{Extract a curvelet band : mrs\_curget}
\index{IDL routines!mrs\_curget}
Extracts a curvelet band from the curvelet transform (see mrs\_curtrans). If the keyword NormMad is set, a normalization is applied (see mrs\_ridget).
 {\bf
\begin{center}
D 3
     Result = mrs\_curget( Cur\_Struct, ScaleWT2D, ScaleRid, NormMad=NormMad, ImaMean=ImaMean, ImaMad=ImaMad )   
E 3
I 3
     USAGE: Result = mrs\_curget( Cur\_Struct, ScaleWT2D, ScaleRid, NormMad=NormMad, ImaMean=ImaMean, ImaMad=ImaMad )   
E 3
\end{center}}
where
\begin{itemize}
\item {\em Cur\_Struct} : Input IDL structure, Curvelet transform structure (see mrs\_curtrans).
\item {\em ScaleWT2D} : int, specifies in which 2D WT scale to get the curvelet band.
\item {\em ScaleRid} : int, specifies which ridgelet band of the specified wavelet scale corresponds to the requested curvelet band. 
\item {\em NormMad} : scalar, if set, normalize the coefficients by the Median Absolution Deviation of all coefficients at a given position in the block.
\item {\em ImaMean} : 2D IDL array: Image containing the mean value for all coefficients at a given position in the block.
\item {\em ImaMad} : 2D IDL array: Image containing the normalization parameters.
\item {\em Result} : 4D IDL float array[*,*,*,12], extracted band
\end{itemize}

\subsubsection*{Example:} 
\begin{itemize}
\item mrs\_curtrans, Imag, Cur   \\
Compute the ridgelet transform
\item Band = mrs\_ridrec(Rid,0,0) \\
Extract the first scale.
\end{itemize}



\subsection{Insert a band into the Curvelet Transform : mrs\_curput}
\index{IDL routines!mrs\_curput}
Inserts a band back in the curvelet transform (see mrs\_curtrans).   
{\bf
\begin{center}
D 3
      mrs\_curput, Cur\_Struct, Band, ScaleWT2D, ScaleRid
E 3
I 3
      USAGE: mrs\_curput, Cur\_Struct, Band, ScaleWT2D, ScaleRid
E 3
\end{center}}
where
\begin{itemize}
\item {\em Cur\_Struct} : Input/Output IDL structure, Curvelet transform structure (see mrs\_curtrans).
\item {\em Band} : 4D IDL float array[*,*,*,12], input band to be inserted in the curvelet transform.
\item {\em ScaleWT2D} : int, specifies in which 2D WT scale to put the given curvelet band.
\item {\em ScaleRid} : int, specifies which ridgelet band of the specified wavelet scale is to be replaced by the given curvelet band. 
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_curtrans, Imag, Cur   \\
Compute the curvelet transform
\item Band = mrs\_curget( Rid, 0, 0) \\
Extract the first scale.
\item Band[*] = 0
Set the band to zero.
\item mrs\_curput, Cur\_Struct, Band, 0, 0 \\
Reinsert the modified band.  
\end{itemize}



\subsection{Curvelet filtering : mrs\_curfilter}
\index{IDL routines!mrs\_curfilter}
\index{curvelet!filtering}
\index{curvelet}
Curvelet denoising of an image on the sphere (Healpix pixel representation). By default Gaussian noise is considered. 
If the keyword SigmaNoise is not set, then the noise standard deviation is automatically estimated. If the keyword MAD 
is set, then a correlated Gaussian noise is considered, and the noise level at each scale is derived from the Median 
Absolution Deviation (MAD) method. If the keyword KillLastScale is set, the coarsest resolution is set to zero. If the 
UNDEC keyword is used, then a undecimated decomposition is used instead of the pyramidal WT. The threshold curvelet 
coefficients can be obtained using the keyword Trans. If the input keyword NITER is set, then an iterative algorithm is 
applied and if the POS keyword is also set, then a positivity constraint is added. If the keyword CYCLE is set, the denoising 
D 3
is performed three times, by shifting the data by PI/4 and -PI/4, denoising the shifted version, and averaging the unshifted 
E 3
I 3
is performed three times, by shifting the data by $\pi/4$ and $-\pi/4$, denoising the shifted version, and averaging the unshifted 
E 3
denoising maps. This procedure allows us to remove the block effect which may appear on the border of the Healpix faces.
{\bf
\begin{center}
D 3
     USAGE:  mrs\_curfilter, Image, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, mad=mad, KillLastScale=KillLastScale, 
     						Trans=Trans, Undec=Undec, FirstBlockSize=FirstBlockSize, niter=niter, pos=pos, cycle=cycle, FirstScale=FirstScale   
E 3
I 3
     USAGE: mrs\_curfilter, Image, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, mad=mad, Trans=Trans, 
     						niter=niter, pos=pos, Undec=Undec, KillLastScale=KillLastScale, FirstBlockSize=FirstBlockSize, 
     						cycle=cycle, FirstScale=FirstScale   
E 3
\end{center}}
where
\begin{itemize}
\item {\em Image} : Input IDL Healpix array containing the input map.
\item {\em Filter} : Output IDL Healpix array containing the output filtered map.
\item {\em NbrScale} : int = Number of scales (default is 4).
\item {\em NSigma} : float = Level of thresholding (default is 3).
\item {\em SigmaNoise} : float = Noise standard deviation. Default is automatically estimated.
\item {\em MAD} : if set, then the noise level is derive at each scale using the MAD of the   
wavelet coefficient. MAD = median ( ABS( WaveletScale) ) / 0.6745.
\item {\em KillLastScale} : if set, the last scale is set to zero.
\item {\em FirstBlockSize} : int Block size in the ridgelet transform at the finest scale (default value is 16).
\item {\em niter} : int, number of iterations used in the reconstruction.
\item {\em pos} : if set, the solution is assumed to be positive.
\item {\em Undec} : if set, an undecimated WT is used instead of the the pyramidal WT.
\item {\em cycle} : int, if set a cycle spanning is applied.
\item {\em FirstScale} : int, consider only scales larger than FirstScale. Default is 1 (i.e. all scales are used).
\item {\em Trans} : Output optional IDL structure for storing the thresholded curvelet decomposition of the input image.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_curfilter, Imag, Filter, NbrScale=5 \\
Pyramidal  Curvelet filtering with five scales.
\item mrs\_curfilter, Imag, Filter, NbrScale=5, Nsigma=5 \\
Ditto, but using a 5 sigma threshold.
\end{itemize}



\subsection{Combined filtering : mrs\_cbfilter}
\index{IDL routines!mrs\_cbfilter}
\index{curvelet!filtering}
\index{wavelet!filtering}
\index{curvelet}
\index{wavelet}
Combined filtering using Wavelet and Curvelet of an image on the sphere (Healpix pixel representation). By default, Gaussian noise 
is considered and if the keyword SigmaNoise is not set, then the noise standard deviation is automatically estimated. If the keyword 
MAD is set, then a correlated Gaussian noise is considered, and the noise level at each scale is derived from the Median Absolution 
Deviation (MAD) method. If the keyword KillLastScale is set, the coarsest resolution is set to zero. If the "undec" keyword is used, 
then a undecimated decomposition is used instead of the pyramidal WT. An iterative algorithm is applied and the keyword NITER gives 
the number of iterations (10 iterations by default).

{\bf
\begin{center}
D 3
     USAGE:  mrs\_cbfilter, Image, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, mad=mad, KillLastScale=KillLastScale, 
     						Undec=Undec, FirstBlockSize=FirstBlockSize, niter=niter, pos=pos, FirstScale=FirstScale     
E 3
I 3
     USAGE: mrs\_cbfilter, Image, Filter, NbrScale=NbrScale, NSigma=NSigma, SigmaNoise=SigmaNoise, mad=mad, niter=niter, pos=pos, 
     						Undec=Undec, KillLastScale=KillLastScale, FirstBlockSize=FirstBlockSize, FirstScale=FirstScale     
E 3
\end{center}}
where
\begin{itemize}
\item {\em Image} : Input IDL Healpix array containing the input map.
\item {\em Filter} : Output IDL Healpix array containing the output filtered map.
\item {\em NbrScale} : int = Number of scales (default is 4).
\item {\em NSigma} : float = Level of thresholding (default is 3).
\item {\em SigmaNoise} : float = Noise standard deviation. Default is automatically estimated.
\item {\em MAD} : if set, then the noise level is derive at each scale using the MAD of the   
wavelet coefficient. MAD = median ( ABS( WaveletScale) ) / 0.6745.
\item {\em KillLastScale} : if set, the last scale is set to zero.
\item {\em niter} : int, number of iterations used in the reconstruction (default value is 10).
\item {\em pos} : if set, the solution is assumed to be positive.
\item {\em Undec} : if set, an undecimated WT is used instead of the the pyramidal WT.
\item {\em FirstBlockSize} : int Block size in the ridgelet transform at the finest scale (default value is 16).
\item {\em FirstScale} : int, consider only scales larger than FirstScale. Default is 1 (i.e. all scales are used).
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_cbfilter, Imag, Filter, NbrScale=5 \\
Pyramidal Curvelet and pyramidal wavelet filtering with five scales.
\item mrs\_cbfilter, Imag, Filter, NbrScale=5, Nsigma=5 \\
Ditto, but using a 5 sigma threshold.
\end{itemize}


D 3

E 3
\section{ICA}

%---------------------------------------------------------------------------
%blind source separation
%---------------------------------------------------------------------------

\subsection{Blind source separation using JADE : mrs\_jade}
\index{IDL routines!mrs\_jade}
\index{ICA!jade}
\index{jade}
\index{jade!wavelet}

D 3
Apply the ICA method JADE~\cite{ica:jade} on data in different settings : the mixed multichannel data gathered from m sensors, 
E 3
I 3
Apply the ICA method JADE~\citep{ica:jade} on data in different settings : the mixed multichannel data gathered from m sensors, 
E 3
may consist of either 1D time series, 2D flat images or spherical maps. A mask can be specified to indicate missing or invalid 
pixels. The components to be separated are all assumed to be independently and identically distributed random fields in the 
specified representation. The possible representations offered here are 'initial' or 'wavelet'. The chosen wavelet transform 
is an orthogonal wavelet transform or an extension of it to the sphere.

{\bf
\begin{center}
D 3
     USAGE:  mrs\_jade, data, topology, nb\_sources, sources, demixingmat, domain = domain, mask = mask, nb\_scales=nb\_scales
E 3
I 3
     USAGE: mrs\_jade, data, topology, nb\_sources, sources, demixingmat, domain = domain, mask = mask, nb\_scales=nb\_scales
E 3
\end{center}}
where
\begin{itemize}
\item {\em data} : either an IDL 2D array of size m*T in the \textbf{'1D'} case, or an IDL 3D array of size tx*ty*m 
in the flat \textbf{'2D'} case, or an array of strings giving the filenames of m spherical data maps in the Healpix 
nested format in the \textbf{'Sphere'} case. 

\item {\em topology} : string = either \textbf{'1D'} or \textbf{'2D'} or \textbf{'Sphere'}. Specifies the topology 
of the maps in the multichannel data to be processed. This is clearly redundant information but makes things simpler. 
The specified 'topology' and the structure of the input data should obviously agree.

\item {\em nb\_sources} : integer = number of independent sources one wants to recover from the data. 
The number of sources should be less than or equal to the number of channels m.

\item {\em sources} : either an IDL 2D array of size nb\_sources*T in the '1D' case, or an IDL 3D array 
of size tx*ty*nb\_sources in the flat '2D' case, or an array of strings giving the predefined filenames 
of nb\_sources spherical data maps in the Healpix nested format in the 'Sphere' case. 

\item {\em demixingmat} : IDL array of size nb\_sources * m. Inverse or pseudo inverse of the mixing matrix, 
used to estimate the source processes from the data according to 'sources = demixingmat * data'.

\item {\em domain} : string = either 'initial' or 'wavelet'. Specifies the representation in which the source separation algorithm 
D 3
JADE should be run \emph{i.e.} the representation in which the cumulant statistics should be computed (default is 'initial').	
E 3
I 3
JADE should be run i.e. the representation in which the cumulant statistics should be computed (default is 'initial').	
E 3

\item {\em mask} : either a length T IDL array in the '1D' case, or an IDL array of size tx*ty in the flat '2D' case, 
or a string giving the filename of a spherical map in the Healpix nested format in the 'Sphere' case. The specified 
mask should be the same size as one of the data maps. A mask is an array of 0s and 1s where 0 indicates an invalid 
data sample, and 1 indicates a valid data sample.

IF A MASK IS SPECIFIED, THE DATAS HAVE TO BE MULTIPLIED BY THE MASK PRIOR TO CALLING THE MRS\_JADE ROUTINE.

\item {\em nb\_scales} : int = number of scales in the wavelet transform including the smooth array (default is nb\_scales = 4). There is no verification that it is a valid number of scales for the given data.

\end{itemize}


\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_jade, data, 'Sphere', 4, sources, demixingmat\\\\
Recovering four independent sources from a set of spherical mixture maps using Jade.  

\item   mrs\_jade, data, '1D', 3, sources, demixingmat, domain = 'wavelet', mask = 'themask.fits', nb\_scales=5\\\\
Recovering three independent sources from a set of 1D mixtures using Jade in a wavelet representation on five scales, with missing samples specified by a mask.  

\end{itemize}



\subsection{Blind source separation using fastICA : mrs\_fastica}
\index{IDL routines!mrs\_fastica}
\index{ICA!fast ICA}
\index{fast ICA}
D 3
Apply the ICA method fastICA~\cite{ica:icabook} on data in different settings : the mixed multichannel data gathered 
E 3
I 3
Apply the ICA method fastICA~\citep{ica:icabook} on data in different settings: the mixed multichannel data gathered 
E 3
from m sensors may consist of either 1D time series, 2D flat images or spherical maps. A mask can be specified to 
indicate missing or invalid pixels. The components to be separated are all assumed to be independently and identically 
distributed random fields in the specified representation. The possible representations offered here are 'initial' 
or 'wavelet'. The chosen wavelet transform is an orthogonal wavelet transform or an extension of it to the sphere.

{\bf
\begin{center}
     USAGE:  mrs\_fastica, data, topology, nb\_sources, sources, demixingmat, domain = domain, mask = mask, nb\_scales=nb\_scales
\end{center}}
where
\begin{itemize}
\item {\em data} : either an IDL 2D array of size m*T in the \textbf{'1D'} case, or an IDL 3D array 
of size tx*ty*m in the flat \textbf{'2D'} case, or an array of strings giving the filenames 
of m spherical data maps in the Healpix nested format in the \textbf{'Sphere'} case. 

\item {\em topology} : string = either \textbf{'1D'} or \textbf{'2D'} or \textbf{'Sphere'}. Specifies the topology 
of the maps in the multichannel data to be processed. This is clearly redundant information but makes things simpler. 
The specified 'topology' and the structure of the input data should obviously agree.

\item {\em nb\_sources} : integer = number of independent sources one wants to recover from the data. 
The number of sources should be less than or equal to the number of channels m.

\item {\em sources} : either an IDL 2D array of size nb\_sources*T in the '1D' case, or an IDL 3D array 
of size tx*ty*nb\_sources in the flat '2D' case, or an array of strings giving the predefined filenames 
of nb\_sources spherical data maps in the Healpix nested format in the 'Sphere' case. 

\item {\em demixingmat} : IDL array of size nb\_sources * m. Inverse or pseudo inverse of the mixing matrix, 
used to estimate the source processes from the data according to 'sources = demixingmat * data'.

\item {\em domain} : string = either 'initial' or 'wavelet'. Specifies the representation in which the source separation algorithm 
fastICA should be run (default is 'initial').	

\item {\em mask} : either a length T IDL array in the '1D' case, or an IDL array of size tx*ty in the flat '2D' case, 
or a string giving the filename of a spherical map in the HEALPix nested format in the 'Sphere' case. The specified 
mask should be the same size as one of the data maps. A mask is an array of 0s and 1s where 0 indicates an invalid 
data sample, and 1 indicates a valid data sample.

IF A MASK IS SPECIFIED, THE DATA HAS TO BE MULTIPLIED BY THE MASK PRIOR TO CALLING THE MRS\_FASTICA ROUTINE.

\item {\em nb\_scales} : int = number of scales in the wavelet transform including the smooth array (default is nb\_scales = 4).  There is no verification that it is a valid number of scales for the given data.

\end{itemize}


\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_fastica, data, 'Sphere', 4, sources, demixingmat\\\\
Recovering four independent sources from a set of spherical mixture maps using fastICA.  

\item   mrs\_fastica, data, '1D', 3, sources, demixingmat, domain = 'wavelet', mask = 'themask.fits', nb\_scales=5\\\\
Recovering three independent sources from a set of 1D mixtures using fastICA in a wavelet representation on five scales, with missing samples specified by a mask.  

\end{itemize}



\subsection{Handling missing/masked data through wavelet scales : mrs\_mask}
\index{IDL routines!mrs\_mask}
\index{mask}
When gaps exist in a signal or a map, some wavelet coefficients located outside the initial mask are affected. The extent of 
the influence of the mask depends on scale. The purpose of this function is to apply the specified wavelet transform to the 
specified mask and to return a mask on each scale where 1s correspond to valid coefficients (i.e. coefficient which are 
contaminated by the mask but below some threshold) and 0s correspond to contaminated coefficients. Implemented for three 
different topologies and "two" different transforms (ie undecimated a trous algorithm or orthogonal transform ): the undecimated 
transform is the one used in mrs\_smica whereas the orthogonal transform is used in mrs\_jade.
{\bf
\begin{center}
D 3
     USAGE: mrs\_mask, mask, topology, wt\_type, nb\_scales, mask\_out, nlmax = nlmax
E 3
I 3
     USAGE: mrs\_mask, mask, topology, wt\_type, nb\_scales, mask\_out, nlmax=nlmax
E 3
\end{center}}
where
\begin{itemize}
\item {\em mask} : either a length T IDL array in the '1D' case, or a tx*ty IDL array in the flat '2D' case, 
or an IDL array in Healpix nested format in the 'Sphere' case.

\item {\em topology} : string = either \textbf{'1D'} or \textbf{'2D'} or \textbf{'Sphere'}. Specifies the topology 
of the maps in the multichannel data to be processed. This is clearly redundant information but makes things simpler. 
The specified 'topology' and the structure of the input data should obviously agree.

\item {\em wt\_type} : string  = either \textbf{'atrous'} or \textbf{'ortho'}. Specifies the wavelet transform type 
to be used, either respectively the undecimated a trous wavelet transform (and extensions in different topologies) 
or the orthogonal wavelet transform (and extensions in the different topologies).

\item {\em nb\_scales} : int = number of scales in the wavelet transform including the smooth array (there is no verification that it is a valid number of scales for the given data).

\item {\em mask\_out}:  
\begin{itemize}
\item{ if wt\_type = 'atrous'}, this is either an nb\_scales*T array in the 1D case, or a tx*ty*nb\_scales array 
in the flat 2D case, or an npix*nb\_scales array of nb\_scales spherical masks in Healpix nested format where npix 
is the size of the initial mask in Healpix nested format.
\item{ if wt\_type = 'ortho'}, this is either a length T array in the 1D case, or a tx*ty array in the flat 2D case, 
or an array the same size as the initial mask in Healpix nested format.		
\end{itemize}

\item {\em nlmax} : this is only used in the undecimated spherical wavelet transform so when the specified topology 
is 'Sphere' and the specified transform is 'atrous'. This is not an optional input in the 'Sphere' AND 'atrous' case. 
D 3
\emph{N.B.}: The same value of nlmax should be used as in the corresponding spherical wavelet transform of the data 
E 3
I 3
N.B.: The same value of nlmax should be used as in the corresponding spherical wavelet transform of the data 
E 3
maps on which the map is to be applied.
\end{itemize}


\subsubsection*{Examples:} 
\begin{itemize}
\item  mrs\_mask, mask, '1D', 'ortho', 5, mask\_out\\\\
Computing the mask to be used on each scale of a 1D orthogonal wavelet transform on five scales of the data.
  
\item  mrs\_mask, mask, 'Sphere', 'atrous', 5, mask\_out, nlmax = 512\\\\
Computing the mask to be used on each scale of an isotropic undecimated spherical wavelet transform on five scales of the data. 
\end{itemize}



\subsection{Morphological Components Analysis on the sphere : mrs\_mca}
\index{IDL routines!mrs\_mca}
\index{spherical mca}
Apply the sparse component analysis method called Morphological Component Analysis, including a hard thresholding 
with linear decreasing threhold, on a spherical map in Healpix representation (NESTED format) using several basis 
decompositions and there transforms on the sphere selected in the following list:
\begin{verbatim}

		1: Isotropic Undecimated Wavelet
		2: Pyramidal Wavelet
		3: Othogonal Wavelet Transform (on each face)
		4: ALM
		5: Dirac
		6: Curvelet
		7: DCT (on each face)
		8: A Trou Wavelet (on each face)
		9: CMBLET

		Default transforms are Pyramidal Wavelet and ALM

\end{verbatim}
With the selection of only one transform and the use of a mask, MCA will make an inpainting of the input data.
{\bf
\begin{center}
D 3
     USAGE: mrs\_mca, data\_in, data\_out, Bounded=Bounded, residual=residual, CstSigma=CstSigma, SelectTrans=SelectTrans, Positivity=Positivity, niter=niter, 
     mad=mad, mom=mom, expo=expo, LastThreshold=LastThreshold, FirstThreshold=FirstThreshold, SigmaNoise=SigmaNoise, NbrScale=NbrScale, lmax=lmax, 
     Mask=Mask, tabNameTrans=tabNameTrans, FirstWTDetectScale=FirstWTDetectScale, soft=soft, DCTblocksize=DCTblocksize, fit=fit, nomean=nomean
E 3
I 3
     USAGE: mrs\_mca, data\_in, data\_out, Bounded=Bounded, residual=residual, CstSigma=CstSigma, SelectTrans=SelectTrans, SigmaNoise=SigmaNoise,
     Positivity=Positivity, LastThreshold=LastThreshold, niter=niter, fit=fit, FirstThreshold=FirstThreshold, tabNameTrans=tabNameTrans, mad=mad, 
     FirstWTDetectScale=FirstWTDetectScale, DCTblocksize=DCTblocksize, NbrScale=NbrScale, mom=mom, expo=expo, soft=soft, 
     lmax=lmax, 
     Mask=Mask, nomean=nomean
E 3
\end{center}}
where 
\begin{itemize}
\item {\em data\_in} : Input 1D IDL array of a Healpix map, image to be analysed.
\item {\em data\_out} : Output 2D IDL array[*, NbTrans] of Healpix maps, components estimated from data\_in. NbTrans is the number 
of selected transforms (via SelectTrans keyword), by default there are 2 transforms.
\item {\em SelectTrans} : 1D int array with the code number of the selected transforms. SelectTrans[i] value must be between 1 and 9. Default value: SelectTrans = [2,4]
\item {\em niter} : int, iteration number of the MCA algorithm. Default value is 10.
\item {\em Mask} : 1D IDL array of Healpix map, mask applied to data\_in. Inpainting on the masked areas.
\item {\em expo} : scalar, if set use an exponential decreasing thresholding instead of linear decreasing thresholding.
\item {\em mom} : scalar, if set use a linear decreasing thresholding with MOM as a first threshold.
\item {\em mad} : scalar, if set use a linear decreasing thresholding with MAD as a first threshold.
\item {\em fit} : scalar, if set fit the threshold levels to ALM decomposition of data\_in.
\item {\em soft} : scalar, if set use soft thresholding instead of hard thresholding.
\item {\em SigmaNoise} : float, standard deviation of the noise, assumed gaussian. Default value is 1.
\item {\em NbrScale} : int, number of scale decompositions for wavelet transfroms. Default value is 5.
\item {\em lmax} : int, maximum l number of spherical harmonics. Default value is 3*nside, max value is 3000.
\item {\em Bounded} : scalar, if set constraints the reconstructed components of data\_out to be bounded by the min and max of data\_in.
\item {\em Positivity} : scalar, if set constraints the reconstructed components of data\_out to be positive.
\item {\em CstSigma} : scalar, if set and if a mask is applied, constraints the decompositions coefficients to have the same standard deviation inside and outside the masked area.
\item {\em nomean} : scalar, if set remove the mean of the reconstructed components of data\_out. Work only with keywords mask and CstSigma.
\item {\em DCTblocksize} : int, size of the blocks for DCT transform (if selected). Default value is the nside parameter of data\_in.
\item {\em FirstWTDetectScale} : int, for isotropic wavelet only, set all wavelet coefficients from Scale < FirstWTDetectScale to 0.
\item {\em LastThreshold} : float, last threshold level. Default value is 0. input / output
\item {\em FirstThreshold} : float, first threshold level. Default is automatically estimated. input / output
\item {\em residual} : Output 1D IDL array of a Healpix map, final residual.
\item {\em tabNameTrans} : Output string array, list of the possible transforms.
tabNameTrans = ['Unknown', 'Isotropic Undecimated Wavelet', 'Pyramidal Wavelet', 'Orthogonal Wavelet Transform', 'ALM', 'DIRAC', 'Curvelet', 'DCT', 'a trous WT', 'CMBLET']
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_mca, Data, Components, SelectTrans=[2,4,5,6] \\
Compute the MCA on a Healpix image data, considering 4 components: Curvelet, ALM, Pyramidal Wavelet and Dirac. 
\end{itemize}



\subsection{Generalized Morphological Components Analysis on the sphere : mrs\_gmca}
\index{IDL routines!mrs\_gmca}
\index{spherical mca}
Apply the blind component separation method called GMCA on spherical maps using Healpix 
representation (NESTED format) with the orthogonal wavelet transform on the sphere.
{\bf
\begin{center}
D 3
     USAGE: mrs\_gmca, Data, NbrSource, RecSource, MixintMat, NbrIter, NbrScale=NbrScale, A0=A0, VARMEAN=VARMEAN, SpecConst=SpecConst, 
E 3
I 3
     USAGE: mrs\_gmca, Data, NbrSource, RecSource, MixintMat, NbrIter, NbrScale=NbrScale, VARMEAN=VARMEAN, SpecConst=SpecConst, A0=A0, 
E 3
     ForceGalactic=ForceGalactic, DustAlmConst=DustAlmConst, SyncAlmConst=SyncAlmConst, GMCA\_mask=GMCA\_mask
\end{center}}
where 
\begin{itemize}
\item {\em Data} : Input 2D IDL float array: Multichannel data on the Sphere (Healpix nested format). Data[*,i] is the ith channel.
\item {\em NbrSource} : int, number of estimated sources. The number of source must be smaller or equal to the number of channels.
\item {\em NbrIter} : int, number of iterations.
\item {\em RecSource} : Output 2D IDL float array, multichannel reconstructed sources. RecSource[*,i] (i=0,NbrSource-1) is the ith source.
\item {\em MixintMat} : Output 2D IDL float array, estimated mixing matrix ( Data = MixintMat \# RecSource ). 
MixintMat is of size NumberChannels $\times$ NbrSource ( MixintMat[0:NumberChannels-1, 0:NbrSource-1] ).
\item {\em NbrScale} : int, number of scales in the wavelet transform. Default value is 4.
\item {\em VARMEAN} : 2D IDL float array, noise covariance matrix given on input, if not set, it is assumed it is identity matrix.
\item {\em GMCA\_mask} : 1D IDL array of Healpix map. optional mask applied to the datas.
\item {\em A0} : 1D IDL float array [0..NumberChannels-1]. If set, then the first column of the matrix is considered as known and does not need to be estimated. We have MixintMat[*, 0] = A0
\item {\em SpecConst} : 2D IDL float array, initial mixing matrix with CMB and SZ spectral contraints (the components 0 and 1 of the mixing matrix are fixed).
\item {\em ForceGalactic} : scalar, if SpecConst is also set then the values of the Dust and Synchrotron spectra (the components 2 and 3 of the mixing matrix) are also fixed.
\item {\em DustAlmConst} : scalar, if set then it constraints the first 769 alm coefficients of the 2nd estimated sources (being the estimated dust).
\item {\em SyncAlmConst} : scalar, if set then it constraints the first 769 alm coefficients of the 3rd estimated sources (being the estimated synchrotron).
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item mrs\_gmca, Data, 4, Sources, mat, 100, NbrScale=5 \\
Compute the GMCA on a 2D data set considering 4 sources, 100 iterations and 5 wavelet scales.
\end{itemize}



\subsection{A few more examples}

Several scripts are included in the package giving examples of how to run the different source separation codes : 
\begin{itemize}
D 3
\item{\emph{test\_mrs\_jade.pro}}
\item{\emph{test\_mrs\_fastica.pro}}
\item{\emph{test\_mrs\_mask.pro}}
E 3
I 3
\item{test\_mrs\_jade.pro}
\item{test\_mrs\_fastica.pro}
\item{test\_mrs\_mask.pro}
E 3
\end{itemize}
These scripts use the data files and masks provided with the package in $\$MRS/data$. These scripts use a procedure 
D 3
called emph{test\_data\_sph.pro} to generate synthetic noisy mixtures of the available component maps on the sphere.
E 3
I 3
called test\_data\_sph.pro to generate synthetic noisy mixtures of the available component maps on the sphere.
E 3



\section{Statistics}

\subsection{Compute several statistics : get\_stat}
\index{IDL routines!get\_stat}
\index{Higher Criticism}
\index{Kurtosis}
\index{statistic}
Return statistical information relative to a given data set. The return value is an IDL array of 9 elements.
\begin{verbatim}

			Tab[0] = standard deviation
			Tab[1] = skewness
			Tab[2] = Kurtosis
			Tab[3] = Min
			Tab[4] = Max 
			Tab[5] = HC
			Tab[6] = HC^+
			Tab[7] = Cumulant of order 5
			Tab[8] = Cumulant of order 6

       If the keyword norm is set, the data are first normalized.
\end{verbatim}
{\bf
\begin{center}
D 3
     USAGE: TabStat = get\_stat( Data, HCIma=HCIma, TabStatName=TabStatName, norm=norm, qpplot=qpplot, verb=verb, zeromean=zeromean, TabCumulant=TabCumulant )  
E 3
I 3
     USAGE: TabStat = get\_stat( Data, HCIma=HCIma, norm=norm, TabStatName=TabStatName, qpplot=qpplot, verb=verb, zeromean=zeromean, TabCumulant=TabCumulant )  
E 3
\end{center}}
where 
\begin{itemize}
\item {\em Data} : IDL array. Input data to analyze. 
\item {\em Norm} : scalar, if set, the input data are normalized and centered (i.e. Data = (Data-Mean)/Sigma).  
\item {\em qpplot} : scalar, if set, plot the qpplot of the data.
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em zeromean} : scalar, if set, the input data are supposed to have a zero mean and are not centered, it is ignored if keyword norm is set.
\item {\em TabStatName} : Output IDL table of string = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em TabCumulant} : IDL double array [0:5]: 6 first cumulants of Data  ( TabCumulant[c] = cumulant of order c+1 )
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = get\_stat( Data, /verb )  \\
Compute statistical information about the data set Data.
\end{itemize}



\subsection{Compute several statistics on the wavelet coefficients : mrs\_wtstat}
\index{IDL routines!mrs\_wtstat}
\index{wavelet!statistics}
\index{wavelet!Kurtosis}
\index{wavelet!Higher Criticism}
\index{Higher Criticism!wavelet}
\index{Kurtosis!wavelet}
\index{statistic}
Return statistical information relative to the wavelet transform of a given data set.
The return value is a 2D IDL array of 9 elements $\times$ Number of scales. For each scale $j$, we have:
\begin{verbatim}
			Tab[0,j] = standard deviation
			Tab[1,j] = skewness
			Tab[2,j] = Kurtosis
			Tab[3,j] = Min
			Tab[4,j] = Max 
			Tab[5,j] = HC
			Tab[6,j] = HC^+
			Tab[7,j] = Cumulant of order 5
			Tab[8,j] = Cumulant of order 6
			
D 3
			If TabFile is set, then the statistic is computed on a set of images. Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
I 3
			If TabFile is set, then the statistic is computed on a set of images.
			Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
\end{verbatim}
{\bf
\begin{center}
D 3
     USAGE: TabStat = mrs\_wtstat( Imag, TabStatName=TabStatName, NbrScale=NbrScale, undec=undec, verb=verb, wt=wt, 
     survival=survival, TabFile=TabFile, TabSurvStat=TabSurvStat, TabAllSurvStat=TabAllSurvStat, TabSurvNu=TabSurvNu )
E 3
I 3
     USAGE: TabStat = mrs\_wtstat( Imag, NbrScale=NbrScale, undec=undec, TabAllSurvStat=TabAllSurvStat, wt=wt, 
     TabStatName=TabStatName, TabSurvNu=TabSurvNu, survival=survival, verb=verb, TabFile=TabFile, TabSurvStat=TabSurvStat )
E 3
\end{center}}
where 
\begin{itemize}
\item {\em Imag} : IDL array of Healpix map. Input image to analyze. 
\item {\em NbrScale} : int = Number of scales. Default is 4.  
\item {\em undec} : scalar, if set, use an undecimated WT instead of the pyramidal WT.
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em TabFile} : Input IDL table of string, list of file where the function read the maps to be analized, in that case, on output, 
Imag is the last map that had been proceed and the return value is a 3D array:\\
Tab[i,j,f] \qquad statistic i for scale j and map TabFile[f].
\item {\em survival} : scalar, if set, use the survival function and activate the keywords parameters 
TabSurvStat, TabAllSurvStat and TabSurvNu for the results.
\item {\em TabStatName} : Output IDL table of string, TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em wt} : Output IDL structure, wavelet transform of the data (see mrs\_wttrans mrs\_pwttrans), if TabFile keyword is used, the last map proceed.
\item {\em TabSurvStat} : Output 2D float array [*,j] survival value at scale j.
\item {\em TabAllSurvStat} : Output 3D double array, use together with TabFile keyword, TabAllSurvStat[*,*,f] is TabSurvStat parameter for map TabFile[f].
\item {\em TabSurvNu} : Output 2D float array [*,j] nu survival value at scale j.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = mrs\_wtstat( Imag, NbrScale=5, /verb ) \\
Compute the pyramidal wavelet transform with 5 scales and compute statistical information relative to each scale of the wavelet transform.
\end{itemize}



\subsection{Compute several statistics on the wavelet coefficients : mrs\_owtstat}
\index{IDL routines!mrs\_owtstat}
\index{wavelet!statistics}
\index{wavelet!Kurtosis}
\index{wavelet!Higher Criticism}
\index{Higher Criticism!wavelet}
\index{Kurtosis!wavelet}
\index{statistic}
\index{wavelet!bi-orthogonal wavelet transform}
\index{wavelet}
Return statistical information relative to the bi-orthogonal wavelet transform of a given data set. The return value is a 2D IDL array 
of 9 elements $\times$ ( Number of scales - 1 )*( d + 1 ) with d = 0, 1, 2 for the 3 directions or only d = 0 if the keyword isotropic is set. 
The coarserst scale is not used. For each scale j, we have:
\begin{verbatim}
D 3
			Tab[0,j*(d+1)] = standard deviation \qquad d = 0 : horizontal band, d = 1 : vertical band, d = 2 : diagonal band
E 3
I 3
			Tab[0,j*(d+1)] = standard deviation
E 3
			Tab[1,j*(d+1)] = skewness
			Tab[2,j*(d+1)] = Kurtosis
			Tab[3,j*(d+1)] = Min
			Tab[4,j*(d+1)] = Max 
			Tab[5,j*(d+1)] = HC
			Tab[6,j*(d+1)] = HC^+
			Tab[7,j*(d+1)] = Cumulant order 5
			Tab[8,j*(d+1)] = Cumulant order 6
I 3
			
			with : d = 0 : horizontal band, d = 1 : vertical band, d = 2 : diagonal band
E 3

D 3
			If TabFile is set, then the statistic is computed on a set of images. Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
I 3
			If TabFile is set, then the statistic is computed on a set of images.
			Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
\end{verbatim}
{\bf
\begin{center}
     USAGE: TabStat = mrs\_owtstat( Imag, TabStatName=TabStatName, NbrScale=NbrScale, verb=verb, TabFile=TabFile, isotropic=isotropic, 
D 3
     survival=survival, TabSurvStat=TabSurvStat, TabAllSurvStat=TabAllSurvStat, TabSurvNu=TabSurvNu )  
E 3
I 3
     TabAllSurvStat=TabAllSurvStat, TabSurvStat=TabSurvStat, TabSurvNu=TabSurvNu, survival=survival )  
E 3
\end{center}}
where 
\begin{itemize}
\item {\em Imag} : IDL array of Healpix map. Input image to analyze. 
\item {\em NbrScale} : int = Number of scales. Default is 4.  
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em isotropic} : scalar, if set, directional information is not taken into account.
\item {\em TabFile} : Input IDL table of string, list of file where the function read the maps to be analized, in that case, on output, 
Imag is the last map that had been proceed and the return value is a 3D array:\\
Tab[i,j,f] \qquad statistic i for scale j and map TabFile[f].
\item {\em survival} : scalar, if set, use the survival function and activate the keywords parameters 
TabSurvStat, TabAllSurvStat and TabSurvNu for the results.
\item {\em TabStatName} : Output IDL table of string, TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em TabSurvStat} : Output 2D float array [*,j] survival value at scale j.
\item {\em TabAllSurvStat} : Output 3D double array, use together with TabFile keyword, TabAllSurvStat[*,*,f] is TabSurvStat parameter for map TabFile[f].
\item {\em TabSurvNu} : Output 2D float array [*,j] nu survival value at scale j.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = mrs\_owtstat( Data, NbrScale=5, /verb )  \\
Compute the bi-orthogonal wavelet transform with 5 scales and compute statistical information 
relative to each scale and each direction of the wavelet transform.
\end{itemize}



\subsection{Compute several statistics on the ridgelet coefficients : mrs\_ridstat}
\index{IDL routines!mrs\_ridstat}
\index{ridgelet!statistics}
\index{ridgelet!Kurtosis}
\index{ridgelet!Higher Criticism}
\index{Higher Criticism!ridgelet}
\index{Kurtosis!ridgelet}
\index{statistic}
Return statistical information relative to the ridgelet transform of a given data set. The return value is a 2D IDL array 
of 9 elements $\times$ Number of scales. For each scale $j$, we have:
\begin{verbatim}
			Tab[0,j] = standard deviation
			Tab[1,j] = skewness
			Tab[2,j] = Kurtosis
			Tab[3,j] = Min
			Tab[4,j] = Max 
			Tab[5,j] = HC
			Tab[6,j] = HC^+
			Tab[7,j] = Cumulant of order 5
			Tab[8,j] = Cumulant of order 6
			
D 3
			If TabFile is set, then the statistic is computed on a set of images. Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
I 3
			If TabFile is set, then the statistic is computed on a set of images.
			Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3

\end{verbatim}
If the keyword NormMad is set, the ridgelet coefficients are first normalized (see {\em mrs\_ridget}).
{\bf
\begin{center}
     USAGE: TabStat = mrs\_ridstat( Data, TabStatName=TabStatName, NbrScale=NbrScale, BlockSize=BlockSize, NormMad=NormMad, verb=verb, 
     Ridtrans=Ridtrans, survival=survival, TabFile=TabFile, TabSurvStat=TabSurvStat, TabAllSurvStat=TabAllSurvStat, TabSurvNu=TabSurvNu )  
\end{center}}
where 
\begin{itemize}
\item {\em Data} : IDL array of Healpix map = Input data to analyze. 
\item {\em NbrScale} : int = Number of scales. Default value is automatically calculated.  
\item {\em BlockSize} : int = Block size used in the ridgelet transform. By default, BlockSize=nside/2.
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em NormMad} : scalar, if set, a normalization is applied to the curvelet coefficient.
\item {\em TabFile} : Input IDL table of string, list of file where the function read the maps to be analized, in that case, on output, 
Imag is the last map that had been proceed and the return value is a 3D array:\\
Tab[i,j,f] \qquad statistic i for scale j and map TabFile[f].
\item {\em Ridtrans} : IDL structure containing the ridgelet transform of Data.
\item {\em survival} : scalar, if set, use the survival function and activate the keywords parameters 
TabSurvStat, TabAllSurvStat and TabSurvNu for the results.
\item {\em TabStatName} : Output IDL table of string, TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em TabSurvStat} : Output 2D float array [*,j] survival value at scale j.
\item {\em TabAllSurvStat} : Output 3D double array, use together with TabFile keyword, TabAllSurvStat[*,*,f] is TabSurvStat parameter for map TabFile[f].
\item {\em TabSurvNu} : Output 2D float array [*,j] nu survival value at scale j.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = mrs\_ridstat( Data, NbrScale=4, /verb ) \\
Compute the ridgelet transform with 4 scales and compute statistical information relative to each scale of the wavelet transform.
\end{itemize}



\subsection{Compute several statistics on the curvelet coefficients : mrs\_curstat}
\index{IDL routines!mrs\_curstat}
\index{curvelet!statistics}
\index{curvelet!Kurtosis}
\index{curvelet!Higher Criticism}
\index{Higher Criticism!curvelet}
\index{Kurtosis!curvelet}
\index{statistic}
Return statistical information relative to the pyramidal curvelet transform of a given data set.
The return value is a 2D IDL array of 9 elements $\times$ Number of scales. For each scale $j$, we have:
\begin{verbatim}
			Tab[0,j] = standard deviation
			Tab[1,j] = skewness
			Tab[2,j] = Kurtosis
			Tab[3,j] = Min
			Tab[4,j] = Max 
			Tab[5,j] = HC
			Tab[6,j] = HC^+
			Tab[7,j] = Cumulant of order 5
			Tab[8,j] = Cumulant of order 6

D 3
			If TabFile is set, then the statistic is computed on a set of images. Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
I 3
			If TabFile is set, then the statistic is computed on a set of images.
			Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
\end{verbatim}
If the keyword NormMad is set, the curvelet coefficients are first normalized (see {\em mrs\_ridget}).
{\bf
\begin{center}
D 3
     USAGE: TabStat = mrs\_curstat( Data, TabFile=TabFile, TabStatName=TabStatName, Firstblocksize=Firstblocksize, NbrScale=NbrScale, normMad=normMad, 
     verb=verb, survival=survival, TabFile=TabFile, TabSurvStat=TabSurvStat, TabAllSurvStat=TabAllSurvStat, TabSurvNu=TabSurvNu )  
E 3
I 3
     USAGE: TabStat = mrs\_curstat( Data, NbrScale=NbrScale, verb=verb, Firstblocksize=Firstblocksize, NbrScale=NbrScale, normMad=normMad, TabFile=TabFile, TabStatName=TabStatName, 
     survival=survival, TabSurvStat=TabSurvStat, TabAllSurvStat=TabAllSurvStat, TabSurvNu=TabSurvNu )  
E 3
\end{center}}
where 
\begin{itemize}
\item {\em Data} : IDL array of Healpix map, Input data to analyze. 
\item {\em NbrScale} : int = Number of scales. Default is 4.  
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em NormMad} : scalar, if set, a normalization is applied to the curvelet coefficient.
\item {\em Firstblocksize:} : int, First block size used in the curvelet transform.
\item {\em TabFile} : Input IDL table of string, list of file where the function read the maps to be analized, in that case, on output, 
Imag is the last map that had been proceed and the return value is a 3D array:\\
Tab[i,j,f] \qquad statistic i for scale j and map TabFile[f].
\item {\em survival} : scalar, if set, use the survival function and activate the keywords parameters 
TabSurvStat, TabAllSurvStat and TabSurvNu for the results.
\item {\em TabStatName} : Output IDL table of string, TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em TabSurvStat} : Output 2D float array [*,j] survival value at scale j.
\item {\em TabAllSurvStat} : Output 3D double array, use together with TabFile keyword, TabAllSurvStat[*,*,f] is TabSurvStat parameter for map TabFile[f].
\item {\em TabSurvNu} : Output 2D float array [*,j] nu survival value at scale j.
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = mrs\_curstat( Data, NbrScale=4, /verb ) \\
Compute the pyramidal curvelet transform with 4 scales and compute statistical information relative to each scale of the wavelet transform.
\end{itemize}



\subsection{Compute several statistics on wavelet, ridgelet and curvelet coefficients : mrs\_allstat}
\index{IDL routines!mrs\_allstat}
Return statistical information relative to several multiscales transforms of a given data set. The six used multiscale transforms are: 
the pyramidal wavelet transform, the isotropic undecimated wavelet transform, the ridgelet transform with a block size equals to 8, 
the ridgelet transform with a block size equals to 16, the ridgelet transform with a block size equals to 32 and the pyramidal curvelet transform.

All statistical informations are computed with the survival option. The return value is a IDL structure with several fields for six transforms statistics:

Each of the statistics fields is a 2D IDL array of 9 elements $\times$ Number of scales and for each scale j, we have:
\begin{verbatim}
			Tab[0,j] = standard deviation
			Tab[1,j] = skewness
			Tab[2,j] = Kurtosis
			Tab[3,j] = Min
			Tab[4,j] = Max 
			Tab[5,j] = HC
			Tab[6,j] = HC^+
			Tab[7,j] = Cumulant of order 5
			Tab[8,j] = Cumulant of order 6

D 3
			If TabFile is set, then the statistic is computed on a set of images. Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
I 3
			If TabFile is set, then the statistic is computed on a set of images.
			Tab[*,*,f] will be the statistic related to the file TabFile[f]
E 3
\end{verbatim}
{\bf
\begin{center}
D 3
     USAGE: StatData = mrs\_allstat( Imag, TabFile=TabFile, NbrScale2D=NbrScale2D, TabStatName=TabStatName, normMad=normMad, verb=verb, 
E 3
I 3
     USAGE: StatData = mrs\_allstat( Imag, NbrScale2D=NbrScale2D, TabFile=TabFile, TabStatName=TabStatName, normMad=normMad, verb=verb, 
E 3
     iwt=iwt, owt=owt, rid8=rid8, rid16=rid16, rid32=rid32, cur=cur, all=all, save=save, TabTransformName=TabTransformName )
\end{center}}
where 
\begin{itemize}
\item {\em StatData} : IDL structure with the following fields:
\begin{itemize}
\item {\em OWT} : IDL float array [ 9, NbrScale ], statistics of the Orthogonal Wavelet Transform.
\item {\em OWTSurv} : TabSurvStat parameter for Orthogonal Wavelet Transform.
\item {\em OWTSurvNu} : TabSurvNu parameter for Orthogonal Wavelet Transform.
\item {\em IWT} : IDL float array [ 9, NbrScale ], statistics of the Isotropic Undecimated Wavelet Transform.
\item {\em IWTSurv} : TabSurvStat parameter for Isotropic Undecimated Wavelet Transform.
\item {\em IWTSurvNu} : TabSurvNu parameter for Isotropic Undecimated Wavelet Transform.
\item {\em Rid8} : IDL float array [ 9, NbrScale ], statistics of the Ridgelet Transform (Length=8).
\item {\em Rid8Surv} : TabSurvStat parameter for Ridgelet Transform (Length=8).
\item {\em Rid8SurvNu} : TabSurvNu parameter for Ridgelet Transform (Length=8).
\item {\em Rid16} : IDL float array [ 9, NbrScale ], statistics of the Ridgelet Transform (Length=16).
\item {\em Rid16Surv} : TabSurvStat parameter for Ridgelet Transform (Length=16).
\item {\em Rid16SurvNu} : TabSurvNu parameter for Ridgelet Transform (Length=16).
\item {\em Rid32} : IDL float array [ 9, NbrScale ], statistics of the Ridgelet Transform (Length=32).
\item {\em Rid32Surv} : TabSurvStat parameter for Ridgelet Transform (Length=32).
\item {\em Rid32SurvNu} : TabSurvNu parameter for Ridgelet Transform (Length=32).
\item {\em Cur} : IDL float array [ 9, NbrScale ], statistics of the Curvelet Transform.
\item {\em CurSurv} : TabSurvStat parameter for Curvelet Transform.
\item {\em CurSurvNu} : TabSurvNu parameter for Curvelet Transform.
\item {\em TabStatName} : IDL table of string: TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
D 3
\item {\em TabTransformName} : IDL table of string: TabTransformName=[ 'Orthogonal Wavelet', 'Isotropic Undecimated Wavelet', 'Ridgelet Transform (Length=8)', 
'Ridgelet Transform (Length=16)', 'Ridgelet Transform (Length=32)', 'Curvelet' ]
E 3
I 3
\item {\em TabTransformName} : IDL table of string: TabTransformName=['Orthogonal Wavelet', 'Isotropic Undecimated Wavelet', 'Ridgelet Transform (Length=8)', 
'Ridgelet Transform (Length=16)', 'Ridgelet Transform (Length=32)', 'Curvelet']
E 3
\item If a transform is not chosen, the three corresponding parameters fields are set to 0.
\end{itemize}
\item {\em Imag} : IDL array of Healpix map. Input image to analyze. 
\item {\em NbrScale2D} : int = Number of scales. Default is 4.  
\item {\em verb} : scalar, if set, the calculated statistics are printed on the screen.
\item {\em NormMad} : scalar, if set, a normalization is applied to the ridgelet and curvelet coefficients.
\item {\em TabFile} : Input IDL table of string, list of file where the function read the maps to be analized, in that case, on output, 
Imag is the last map that had been proceed and the return value is a 3D array:\\
Tab[i,j,f] \qquad statistic i for scale j and map TabFile[f].
\item {\em iwt} : scalar, if set, the statistics of the Isotropic Undecimated Wavelet Transform are computed.
\item {\em owt} : scalar, if set, the statistics of the Orthogonal Wavelet Transform are computed.
\item {\em rid8} : scalar, if set, the statistics of the Ridgelet Transform (Length=8) are computed.
\item {\em rid16} : scalar, if set, the statistics of the Ridgelet Transform (Length=16) are computed.
\item {\em rid32} : scalar, if set, the statistics of the Ridgelet Transform (Length=32) are computed.
\item {\em cur} : scalar, if set, the statistics of the Curvelet Transform are computed.
\item {\em all} : scalar, if set, the statistics of all the 6 transforms are computed.
\item {\em save} : scalar, if set, the results are saved in separate files.
\item {\em TabStatName} : Output IDL table of string, TabStatName = [ "Sigma", "Skewness", "Kurtosis", "Min", "Max", "HC1", "HC2", "CUMULANT ORDER 5", "CUMULANT ORDER 6" ]
\item {\em TabTransformName} : Output IDL table of string: 
TabTransformName=[ 'Orthogonal Wavelet', 'Isotropic Undecimated Wavelet', 'Ridgelet Transform (Length=8)', 'Ridgelet Transform (Length=16)', 'Ridgelet Transform (Length=32)', 'Curvelet' ]
\end{itemize}

\subsubsection*{Examples:} 
\begin{itemize}
\item TabStat = mrs\_allstat( Data, NbrScale2D=4, /verb, /all)  \\
Compute the six transforms with 4 scales and compute statistical information relative to each scale and transform.
\end{itemize}

E 1
I 2




\section{Tutorial}
 % MR/S is available for download at:  \\
% {\centerline{\texttt{http://jstarck.free.fr/mrs.html}}}

\subsection{Undecimated Wavelet Transform on the Sphere}
The code to generate the undecimated wavelet transform of the Mars 
image of Fig.~\ref{Figure:UWTS} is as follows. 
\begin{verbatim}
; read the data 
m = mrs_read('mars_topo_mola_hpx_128.fits')

; compute the undecimated wavelet transform with 5 scales
mrs_wttrans, m, w,nbrscale=5

; Display and write the figures to the disk
tvs, m, tit='Mars topographic map', png='fig_mars.png'
tvs, w.coef[*,0], tit='Mars topographic map: scale 1', $
                   png='fig_mars_scale1.png' 
tvs, w.coef[*,1], tit='Mars topographic map: scale 2', $
                   png='fig_mars_scale2.png'
tvs, w.coef[*,2], tit='Mars topographic map: scale 3', $
                   png='fig_mars_scale3.png'
tvs, w.coef[*,3], tit='Mars topographic map: scale 4', $
                   png='fig_mars_scale4.png'
tvs, w.coef[*,4], tit='Mars topographic map: scale 5', $
                   png='fig_mars_scale5.png'
\end{verbatim}

\subsection{Pyramidal Wavelet Transform on the Sphere}
The code to generate the pyramidal wavelet transform of the Mars 
image of Fig.~\ref{Figure:PWTS} is as follows.  
\index{sphere!pyramidal wavelet}

\begin{verbatim}
; read the data 
e = mrs_read('earth_healpix_128.fits')

; compute the pyramidal wavelet transform with 5 scales
mrs_pwttrans, e, we, nbrscale=5

; Display and write the figures to the disk
mrs_wttv, we, write='fig_earth'
\end{verbatim}


\subsubsection{Denoising}
In the denoising experiment of Fig.~\ref {Figure:sync_filter} and Fig.~\ref{Figure:sync_cbf_filter}, 
we have added Gaussian noise to the astronomical simulated synchrotron emission map.
The code to generate the figures is as follows.
\begin{verbatim}
; read the image
s = rims('sync_res128.fits')

; add Gaussian noise
n = randomn(seed, N_ELEMENTS(s))
SigmaNoise = 5.
s1 = s + n* SigmaNoise
 
; Denoising using the undecimated WT on the sphere at 4sigma
Nsig = 4.
 mrs_wtfilter, s1, fwt4, nsigma= Nsig, nbrscale=5, SigmaNoise=SigmaNoise

; Denoising using the curvelet transform
mrs_curfilter, s1, fct4, nsigma= Nsig, nbrscale=5, SigmaNoise=SigmaNoise

; Denoising using the combined denoising
mrs_cbfilter, s1, fcb4, nsigma= Nsig, nbrscale=5, SigmaNoise=SigmaNoise

; Display and write the figure to the disk
tvs, s, /log, tit='Synchrotron emission', png='fig_sync.png'
tvs, s1 > 30, /log, tit='Synchrotron emission + noise', $
                   png='fig_sync_noise5.png'

tvs , fwt4 > 30, /log, title='Undecimated Wavelet Denoising (4sigma)', $
                   png='fig_sync_wtfilter5.png'
tvs , fct4 > 30, /log, title='Curvelet Denoising (4sigma)',  $
                   png='fig_sync_curfilter5.png'
tvs , fcb4 > 30, /log, title='Combined Filtering (4sigma)',  
                   png='fig_sync_cbfilter5.png'

tvs , s1- fwt4,   title='Residual undecimated Wavelet Denoising (4sigma)', $
                   png='fig_sync_resi_wtfilter5.png'
tvs , s1 - fct4,  title='Residual  curvelet Denoising (4sigma)',  $
                   png='fig_sync_resi_curfilter5.png'
tvs , s1  - fcb4,  title='Residual  combined Filtering (4sigma)',  $
                   png='fig_sync_resi_cbfilter5.png'

; Print the standard deviation (error) between the true image 
; and the denoised images
print, 'Err WT = ', sigma(s-fwt4) , ', Err Cur  = ', sigma(s-fct4),  ',  $
                  Err Comb = ', sigma(s-fcb4)

\end{verbatim}

We find the outcome here to be:

\begin{verbatim}
==>  Err WT = 1.25,  Err Cur  = 1.07,  Err Combined = 0.86
\end{verbatim}


E 2
