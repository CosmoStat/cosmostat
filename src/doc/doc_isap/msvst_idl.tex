 
\chapter{IDL Routines}
\label{ch_idlproc}

\markright{IDL Routines}
 
\section{Denoising using MS-VSTS + Isotropic Undecimated Wavelet Transform}
%\section{IDL routines for simulated data}

\subsection{Main routine}

\vspace{0.3cm}

$\blacktriangleright$   \textbf {Starting from a photon counts map}

\vspace{0.3cm}

$\looparrowright$ \textbf{mrs\_msvsts\_IUWT\_denoising.pro} :  Compute Poisson denoising on spherical HEALPix data with MS-VSTS + Isotropic Undecimated Wavelet Transform method.


\begin{center}
 \bf{USAGE : mrs\_msvsts\_IUWT\_denoising, image, image\_reconstruite, NbrScale=NbrScale, niter=niter, HSD=HSD, coef\_seuil=coef\_seuil, coef\_pos=coef\_pos, First\_Scale=First\_Scale, mask=mask, filter=filter, pyr=pyr, background=background, expo=expo, alm=alm, curv=curv, separation=separation, back\_reconstruit=back\_reconstruit, update\_support=update\_support, split\_support=split\_support}
\end{center}

\textbf{INPUTS} : 
\begin{itemize}
\item{Image = (IDL array) HEALPix data to be denoised}
\item{(Optional) background = (IDL array) if set, substracts a background to the data}
\item{(Optional) support = (IDL array) if set, use a given multi-resolution support instead of computing it with the procedure mrs\_msvsts\_hypothesis\_testing}
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
\item{Image\_reconstruite = (IDL array) HEALPix denoised image}
\item{(optional) Support = (IDL array) multi-resolution support of the image}
\item{(optional) Back\_reconstruit = (IDL array) if set, returns the reconstructed background (need the keyword separation)}
\end{itemize}

\textbf{KEYWORD}

\begin{itemize}
  \item NbrScale  : Number of scales (default is 4)
  \item niter  : Number of iterations
  \item HSD  : if set, the denoised image will be recontructed using the Hybrid Steepest Descent Method (soft thresholding at each iteration of the reconstruction)
  \item  coef\_seuil  : determines the threshold for the detection of significant coefficients. For each scale i, the threshold is set to $\text{coef\_seuil}*\sigma_i$ (default is 5)
  \item coef\_pos  : if set, negative wavelets coefficients are set to 0.
  \item  First\_Scale  : if $> 2$, finer wavelet scales are set to 0. (default is 1)
  \item  mask  : if set, enables impainting with the given mask
  \item filter  : if set, the inverse wavelet transform will be computed using filters. Else, it will be obtained by a simple addition of all wavelet scales.
  \item pyr  : if set, use pyramidal wavelet transform for the soft thresholding
  \item expo  : if set, decreases the thresold exponentially at each step of the HSD. Else, decreases the threshold linearly
  \item alm : if set, thresholding is made on alm coefficients instead of wavelet coefficients
  \item  curvelets : if set, thresholding is made on curvelets coefficients instead of wavelet coefficients
  \item  separation : if set, compute separately the sources and the background
  \item  update\_support : if set, update the multi-resoluation support at each iteration
  \item  split\_support : if set, splits the multi-resolution support
\end{itemize}




\subsection{Subroutines}

\vspace{0.3cm}
%$\twoheadrightarrow$
$\looparrowright$ \textbf{mrs\_msvsts\_IUWT\_param\_computing.pro} :  For a given number of scales, determines the VST operator at each scale for the MS-VST transform with spherical isotropic Undecimated Wavelet Transform. At scale j, the VST operator is: $T_j(a_j) = b_{(j)} * sgn(a_j+c_{(j)}) * \sqrt{(|a_j+c_{(j)}|)}$ where $a_j$ is the jth scale coefficient of the wavelet transform.

\begin{center}
 \bf{USAGE : mrs\_msvsts\_IUWT\_param\_computing,nbr,c,b,h,tau1,tau2,tau3,sigma}
\end{center}

\textbf{INPUTS} : 
\begin{itemize}
\item{nbr = (int) number of scales for the MS-VST transform}
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
\item{c = (1D IDL array) vector of the c(j) coefficients for each scale j}
\item{b = (1D IDL array) vector of the b(j) coefficients for each scale j}
\item{h = (IDL array) h[*,j] is the low pass filter which gives the jth scale from the original image}
\item{tau1 = (1D IDL array) vector of the 1st order moments of h[*,j] for each scale j}
\item{tau2 = (1D IDL array) vector of the 2st order moments of h[*,j] for each scale j}
\item{tau3 = (1D IDL array) vector of the 3rd order moments of h[*,j] for each scale j}
\item{sigma = (1D IDL array) vector of the asymptotic standard deviations of detail coefficients issued from locally homogeneous parts of a signal for each wavelet scale}
\end{itemize}

\vspace{0.3cm}
%$\twoheadrightarrow$
$\looparrowright$ \textbf{mrs\_msvsts\_IUWT\_transform.pro} :  Computes the multi-scale variance stabilising transform on the sphere with undecimated isotropic wavelet transform, using the HEALPix representation (nested data representation). The wavelet function is zonal and its spherical harmonics coefficients $a_{l0}$ follow a cubic box-spline profile. If DifInSH is set, wavelet coefficients are derived in the Spherical Harmonic Space, otherwise (default) they are derived in the direct space.

\begin{center}
 \bf{USAGE : mrs\_msvsts\_IUWT\_transform, Imag, Trans, NbrScale=NbrScale, lmax=lmax, DifInSH=DifInSH}
\end{center}

\textbf{INPUTS} :
\begin{itemize}
\item{Imag = (IDL array) HEALPix data}
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
\item{Trans = IDL structure with the following fields:
\begin{itemize}
  \item NbrScale = (int) number of scales 
  \item nside = (int) Healpix nside parameter
  \item lmax = (int) Maximum l value in the Spherical Harmonic Space (Healpix)
  \item npix = (int) Number of pixels of the input image (12*nside*nside)
  \item Coef = (IDL array) stabilised wavelet transform of the data
  \item Coef[*,0] = stabilised wavelet coefficients of the finest scale (highest frequencies).
  \item Coef[*,NbrScale-1] = coarsest scale (lowest frequencies). 
  \item lmax = (int) lmax parameter at the first scale
\end{itemize} }
\end{itemize}

\textbf{KEYWORDS} :
\begin{itemize}
  \item NbrScale = (int) Number of scales (default is 4)
  \item Lmax = (int) Number of spherical harmonics computed in the decomposition (default is 3*nside, should be between 2*nside and 4*nside)
  \item DifInSH   : If set, compute the wavelet coefficients as the difference between two resolution in the spherical harmonics representation. Otherwise, the wavelet coefficients are computed as the difference between two resolutions in the initial representation.
\end{itemize}

\vspace{0.3cm}
%$\twoheadrightarrow$
$\looparrowright$ \textbf{mrs\_msvsts\_IUWT\_hypothesis\_testing.pro} :  Computes the MS-VSTS + Isotropic Undecimate Wavelet Transform of a Poisson Image, perform hypothesis testing on coefficients, returns the multi-resolution support and the denoised image using direct reconstruction

\begin{center}
 \bf{USAGE : mrs\_msvsts\_IUWT\_hypothesis\_testing, image, image\_vst, support, image\_rec, NbrScale=NbrScale, coef\_seuil=coef\_seuil, First\_Scale=First\_Scale, background=background}
\end{center}

\textbf{INPUTS} :
\begin{itemize}
  \item Imag = (IDL array) HEALPix data
  \item (optional) background = (IDL array) if set, substracts a background to the image.
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
  \item image\_vst = (IDL structure) MS-VSTS transform of the image computed with mrs\_msvsts\_IUWT\_transform
  \item support = (IDL array) multi-resolution support
  \item image\_rec = (IDL array) directly reconstructed denoised image
\end{itemize}

\textbf{KEYWORDS} :
\begin{itemize}
  \item NbrScale = (int) Number of scales (default is 4)
  \item coef\_seuil = (int) determines the threshold for the detection of significant coefficients. For each scale i, the threshold is set to $\text{coef\_seuil}*\sigma_i$ (default is 5)
  \item First\_Scale = (int) if $> 2$, finer wavelet scales are set to 0. (default is 1)
\end{itemize}


\section{Denoising using MS-VSTS + Curvelet Transform}

\subsection{Main routine}

$\looparrowright$ \textbf{mrs\_msvsts\_curv\_denoising.pro} :  Compute Poisson denoising on spherical HEALPix data with MS-VSTS + Curvelet Transform method.


\begin{center}
 \bf{USAGE : mrs\_msvsts\_curv\_denoising, image, image\_reconstruite, support, nbrscale=nbrscale, coef\_seuil=coef\_seuil, suppr\_scale1=suppr\_scale1, hsd=hsd, niter=niter}
\end{center}

\textbf{INPUTS} : 
\begin{itemize}
\item{Image = (IDL array) HEALPix data to be denoised}
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
\item{Image\_reconstruite = (IDL array) HEALPix denoised image}
\item{(optional) Support = (IDL array) multi-resolution support of the image}
\end{itemize}

\textbf{KEYWORD} :

\begin{itemize}
  \item NbrScale = Number of scales (default is 4)
  \item HSD = if set, the denoised estimate will be recontructed using the Hybrid Steepest Descent Method (soft thresholding at each iteration of the reconstruction). If not set, the estimate is direclty reconstructed.
  \item niter = Number of iterations
   \item coef\_seuil = determines the threshold for the detection of significant coefficients. For each scale i, the threshold is set to $\text{coef\_seuil}*\sigma_i$ (default is 5)
  \item coef\_pos = if set, negative wavelets coefficients are set to 0.
  \item suppr\_scale1 = if set, remove the finest scale from the reconstructed estimate.
\end{itemize}

\subsection{Subroutines}
$\looparrowright$ \textbf{mrs\_msvsts\_curv\_transform.pro} : Compute the multi-scale variance stabilizing transform on the sphere with standard undecimated curvelet transform on the sphere, using the healPix pixel representation (nested data representation). A band of the curvelet transform is defined by two number, the 2D WT scale number and the ridgelet scale number. The output is a IDL structure.


\begin{center}
 \bf{USAGE : mrs\_msvsts\_curv\_transform, Imag, Trans, lmax=lmax, NbrScale=NbrScale, FirstBlockSize=FirstBlockSize}
\end{center}

\textbf{INPUTS} : 
\begin{itemize}
\item{Image = (IDL array) HEALPix data to be transformed}
\end{itemize}

\textbf{OUTPUTS} : 
\begin{itemize}
\item Trans = IDL structures with the following fields:
 \begin{itemize}
  \item NBRSCALE = (INT) Nbr of the scale in the 2D WT
  \item TABBLOCKSIZE = (INT) TABBLOCKSIZE[j], Block size in the ridgelet transform at scale j.
  $j = [0..NBRSCALE-2]$
  \item TABNBRSCALERID = (INT) TABNBRSCALERID[j], number of ridgelet band at scale j 
  \item TABNORM = (2D IDL ARRAY) Normalization array
  \item RIDSCALE1 = (IDL STRUCT) ridgelet transform of the first wavelet scale (see mrs\_ridtrans.pro for details)
  \item RIDSCALEj = (IDL STRUCT) ridgelet transform of the jth wavelet scale.
  $j = [0..NBRSCALE-2]$
  \item LASTSCALE = (IDL 1D array) Healpix image of the coarsest scale
  \item WT = (IDL STRUCT) Wavelet structure (for internal use only)
  \item PYRTRANS = (INT) equal to 1 for a pyramidal curvelet transform and 0 otherwise
 \end{itemize}
\end{itemize}

\textbf{KEYWORD} :

\begin{itemize}
  \item NbrScale = (INT) Number of scale in the 2D wavelet transform (defaut 4)
  \item Undec = (INT) if set, an undecimated curvelet transform is used instead of the pyramidal curvelet transform
  \item FirstBlockSize = (INT) Block size in the ridgelet transform at the finest scale (default is 16)
  \item Lmax = (INT) Number of used spherical harmoniques used in the wavelet transform (defaut = 3*nside, should be between 2*nside and 4*nside)
  \item Overlap = (LONG) is equal to 1 if blocks are overlapping
\end{itemize}

\section{Multichannel Denoising using MS-VSTS + Multichannel Wavelet Transform}

%\subsection{Main routine}

\vspace{0.3cm}

$\blacktriangleright$   \textbf {Starting from a set of photon counts maps}

\vspace{0.3cm}

$\looparrowright$ \textbf{mrs\_msvsts\_multichannel\_denoising.pro} :  Compute multichannel Poisson denoising on spherical 2D-1D HEALPix data with MS-VSTS + multichannel Wavelet Transform method.

\begin{center}
 \bf{USAGE : mrs\_msvsts\_multichannel\_denoising,input,solution,NbrScale1=NbrScale1,NbrScale2=NbrScale2,niter=niter
}
\end{center}

\textbf{INPUT} : 
\begin{itemize}
\item{Input = (IDL array) multichannel HEALPix data to be denoised}
\end{itemize}

\textbf{OUTPUT} : 
\begin{itemize}
\item{Solution = (IDL array) multichannel HEALPix denoised image}
\end{itemize}

\textbf{KEYWORD}

\begin{itemize}
  \item NbrScale1 : Number of scales for the two spatial dimensions (default is 6)
  \item NbrScale2 : Number of scales for the non-spatial dimension (time or energy) (default is 6)
  \item niter  : Number of iterations
\end{itemize}

\vspace{0.3cm}

%\subsection{subroutines}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{mrs\_msvsts\_multichannel_denoising.pro}


\section{Multichannel Deconvolution using MS-VSTS + Multichannel Wavelet Transform}

\vspace{0.3cm}

$\blacktriangleright$   \textbf {Starting from a set of photon counts maps}

\vspace{0.3cm}

$\looparrowright$ \textbf{mrs\_msvsts\_multichannel\_deconvolution.pro} :  Compute multichannel Poisson deconvolution on spherical 2D-1D HEALPix data with MS-VSTS + multichannel Wavelet Transform method.

\begin{center}
 \bf{USAGE : mrs\_msvsts\_multichannel\_deconvolution,input,solution,NbrScale1=NbrScale1,NbrScale2=NbrScale2,niter=niter,beam=beam,regularization}
\end{center}

\textbf{INPUT} : 
\begin{itemize}
\item{Input = (IDL array) multichannel HEALPix data to be denoised}
\item{beam = (IDL array) set of convolution beams}
\end{itemize}

\textbf{OUTPUT} : 
\begin{itemize}
\item{Solution = (IDL array) multichannel HEALPix denoised image}
\end{itemize}

\textbf{KEYWORD}

\begin{itemize}
  \item NbrScale1 : Number of scales for the two spatial dimensions (default is 6)
  \item NbrScale2 : Number of scales for the non-spatial dimension (time or energy) (default is 6)
  \item niter  : Number of iterations
  \item regularization : if set, uses a regularization parameter (set to 0.01) to improve the convergence speed of the algorithm
\end{itemize}






%$\looparrowright$  \textbf{add\_gnoise\_kappa.pro} : Add a Gaussian noise to a mass map structure :
%\index{add\_gnoise\_kappa.pro}
%\noindent Add a Gaussian noise to the mass map by adding a gaussian noise to the shear maps depending on the number of galaxies per pixel.



%\begin{center}
% \textbf{USAGE : add\_gnoise\_kappa, smap, ng, s, smapn}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map}
%\item{ng = (int) galaxies number per arcmin square}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{s = (int) the root mean square of the noise}
%\item{smapn = IDL structure of mass map embedded in a gaussian noise with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) noisy mass map}
%\end{itemize}

%
%$\blacktriangleright$   \textbf {Starting from a shear maps without noise}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{mk\_gamma.pro} : Build a shear maps structure from shear maps :
%\index{mk\_gamma.pro}
%\noindent Build a shear maps structure from shear maps and the field size in pixels and in degrees (or arcmin)

%\begin{center}
% \bf{USAGE : mk\_gamma, gamma1, gamma2, npix1, npix2, theta1, theta2, amin = amin, sgamma}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gamma1, gamma2 = IDL array of shear maps $\gamma_1$ and $\gamma_2$}
%\item{npix1, npix2 = (int) map size in pixels}
%\item{theta1, theta2 = (int) map size in degrees (or arcmin if the keyword amin is set)}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{amin = (string) if set, the map size theta1 and theta2 are assumed to be in arcmin}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{sgamma = shear maps IDL structure with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\end{itemize}

%
%$\looparrowright$  \textbf{add\_gnoise\_gamma.pro} : Add a Gaussian noise to a shear maps structure :
%\index{add\_gnoise\_gamma.pro}
%\noindent Add a Gaussian noise to the shear maps depending on the number of galaxies per pixel.

%\begin{center}
% \textbf{USAGE : add\_gnoise\_gamma, sgamma, ng, s, sgamman}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{sgamma = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\item{ng = (int) galaxies number per arcmin square}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{s = (int) the root mean square of the noise}
%\item{sgamman = IDL structure of shear maps embedded in a gaussian noise with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) noisy shear maps $\gamma_{1b}$ and $\gamma_{2b}$}
%\end{itemize}

%
%$\looparrowright$  \textbf{gamma\_to\_kappa.pro} : Derive a mass map structure from a shear maps structure:
%\index{gamma\_to\_kappa.pro}
%\noindent Derive a mass map structure from shear maps structure using the relation \ref{eqn_reckE} in
%chapter \ref{ch_weak}.

%\begin{center}
% \textbf{USAGE : gamma\_to\_kappa, sgamma, smap}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{sgamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{cat = (string) if set, some fields (specific to real data) are added to the output mass map structure (ng, wtot, mask, gamma\_err, kappa\_err, ng\_eff, sigma\_gamma,x1\_ran, x2\_ran, x1\_m, x2\_m)}
%\item{bmode = (string) if set, the magnetic component of the mass map is computed, otherwise is the electric component that is computed}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}

%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%\textbf{if keyword\_set(cat) : }
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of  each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }
%\end{itemize}

%\subsection{IDL routines for real data}

%\vspace{0.3cm}

%$\blacktriangleright$   \textbf {Build a catalogue structure}

%\vspace{0.3cm}
%%$\twoheadrightarrow$
%$\looparrowright$ \textbf{mk\_gcat.pro} : Build a shear catalogue structure :
%\index{mk\_gcat.pro}
%\begin{center}
% \textbf{USAGE : mk\_gcat, x, y, pixscale, weight, g1, g2, gcat}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{x, y = (1D IDL array) coordinates in pixels of each galaxy}
%\item{pixscale = (int) pixel size [in rad]}
%\item{weight = (1D IDL array) weight of each galaxy}
%\item{g1, g2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{gcat = IDL structure of catalogue with the following fields : \\
%- x, y = (1D IDL array) coordinates in pixels of each galaxy\\
%- pixscale = (int) pixel size [in deg] \\
%- weight = (1D IDL array) weight of each galaxy \\
%- gamma1, gamma2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%$\blacktriangleright$   \textbf {Build a shear maps structure}

%\vspace{0.3cm}
%%$\twoheadrightarrow$
%$\looparrowright$ \textbf{gcat\_to\_gamma.pro} : Build a (pixelised) shear maps structure from a shear catalogue structure :
%\index{gcat\_to\_gamma.pro}
%\begin{center}
% \textbf{USAGE : gcat\_to\_gamma, gcat, gamma, delta=delta}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gcat = IDL structure of catalogue with the following fields : \\
%- x, y = (1D IDL array) galaxies position in pixels of each galaxy\\
%- pixscale = (int) pixel size [in rad] \\
%- weight = (1D IDL array) weight of each galaxy \\
%- gamma1, gamma2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{delta = (string) pixel size in $arcmin$, default is 1}
%\end{itemize}

%

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{gamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel \\
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }\\
%\end{itemize}

%
%\section{Relations between the distortion field and the projected (Electric) mass concentration}

%\vspace{0.3cm}

%\subsection{From shear maps $\gamma_1$, $\gamma_2$ to mass map $\kappa$}
%$\looparrowright$ \textbf{gamma\_to\_kappa.pro} : See description in previous subsection.\\
%\index{gamma\_to\_kappa.pro}

%\subsection{From mass map $\kappa$ to shear maps $\gamma_1$, $\gamma_2$}
%$\looparrowright$ \textbf{kappa\_to\_gamma.pro} : Derive a shear maps structure from a mass map structure using the relation \ref{eq_gamma} in chapter \ref{ch_weak}.

%\begin{center}
% \textbf{USAGE : kappa\_to\_gamma, smap, sgamma}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map $\kappa$}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{cat = (string) if set, some fields (specific to real data) are added to the output mass map structure (ng, wtot, mask, gamma\_err, kappa\_err, ng\_eff, sigma\_gamma,x1\_ran, x2\_ran, x1\_m, x2\_m)}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}

%\item{sgamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%\textbf{if keyword\_set(cat) : }
%\item{sgamma = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\ 
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }
%\end{itemize}


%A set of routines has been developed in IDL (summarized in flowchart Fig. \ref{organigramme}). Starting IDL using the script program {\em mrl.pro} allows the user to add the MRLENS software to the IDL environment. Thus, all routines described in the following can be called. An online help, facility is also available by calling the {\em  mrh} IDL program.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Installation}

%\subsection{System requirements}
%\begin{itemize}
%\item Disk space : Make sure you have approximately 400 MB of disk space available. After installation MRLENS package occupies approximately 100 MB or 200MB (version with data) of disk space.\\
%\item Platform : The binaries C++ called by IDL routines are not available under all the systems therefore you cannot use the package on all platforms. The supported platforms are : Unix, Linux, Mac OS X. They will be soon available in Windows platform.\\
%\end{itemize}

%\subsection{Download}
%Use the link to download the package MRL and copy the file in your home directory (/home/user/).\\
%Then, uncompress the filename.tar.gz file by typing:\\
%gunzip filename.tar.gz \\
%tar -xvf filename.tar\\

%
%\subsection{Installation instructions}
%The MRLENS package requires that IDL (version 6.0 or later) to be installed. 
%The alias \textbf{idl} should also be defined to launch the 
%IDL environment. Then, installing the MRLENS package simply requires adding 
%some lines in your shell environment profile depending on your shell :
%(The command "echo \$SHELL" will give your SHELL environment : bash, csh or tcsh)
%\begin{itemize}
%\item{define the environment variable \textbf{MRL} :\\
%In csh or tcsh :\\
%setenv MRL /home/user/MRL\\ 
%In bash :\\ 
%MRL=/home/user/MRL;export MRL} \\
% \item{define the alias \textbf{mrl} \\  
% In csh or tcsh :\\
% alias mrl  'idl \$MRL/idl/mrl' \\ 
% In bash :\\
% alias mrl ='idl \$MRL/idl/mrl'} \\
%\end{itemize}

%\subsection{Startup instructions}
%The command "mrl" will start the IDL session using the MRL environment.
%The programs can be found in \$MRL/idl.
%These routines use data in directory \$MRL/Data.
%The command "mrh" will open the online help.\\

%Two scripts are included in the package giving examples of how to run some main routines :\\
%- mk\_test\_1.pro\\
%- mk\_test\_2.pro\\
%These scripts use the data files provided with the package in \$MRL/Data. The first use a simulated noiseless mass map and the second a simulated noisy catalogue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Build an Electric noisy mass map}
%%\section{IDL routines for simulated data}

%\subsection{IDL routines for simulated data}

%\vspace{0.3cm}

%$\blacktriangleright$   \textbf {Starting from a mass map without noise}

%\vspace{0.3cm}
%%$\twoheadrightarrow$
%$\looparrowright$ \textbf{mk\_kappa.pro} : Build a mass map structure from a mass map :
%\index{mk\_kappa.pro}

%\noindent Build a mass map structure from the mass map and the field size in pixels and in degrees (or arcmin)
%\begin{center}
% \bf{USAGE : mk\_kappa, map, npix1, npix2, theta1, theta2, amin = amin, smap}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{map = IDL array of mass map}
%\item{npix1, npix2 = (int) map size in pixels}
%\item{theta1, theta2 = (int) map size in degrees (or arcmin if the keyword amin is set)}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{amin = (string) if set, the map size theta1 and theta2 are assumed to be in arcmin}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{smap = mass map IDL structure with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map}\\
%\end{itemize}

%$\looparrowright$  \textbf{add\_gnoise\_kappa.pro} : Add a Gaussian noise to a mass map structure :
%\index{add\_gnoise\_kappa.pro}
%\noindent Add a Gaussian noise to the mass map by adding a gaussian noise to the shear maps depending on the number of galaxies per pixel.

%\begin{center}
% \textbf{USAGE : add\_gnoise\_kappa, smap, ng, s, smapn}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map}
%\item{ng = (int) galaxies number per arcmin square}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{s = (int) the root mean square of the noise}
%\item{smapn = IDL structure of mass map embedded in a gaussian noise with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) noisy mass map}
%\end{itemize}

%
%$\blacktriangleright$   \textbf {Starting from a shear maps without noise}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{mk\_gamma.pro} : Build a shear maps structure from shear maps :
%\index{mk\_gamma.pro}
%\noindent Build a shear maps structure from shear maps and the field size in pixels and in degrees (or arcmin)

%\begin{center}
% \bf{USAGE : mk\_gamma, gamma1, gamma2, npix1, npix2, theta1, theta2, amin = amin, sgamma}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gamma1, gamma2 = IDL array of shear maps $\gamma_1$ and $\gamma_2$}
%\item{npix1, npix2 = (int) map size in pixels}
%\item{theta1, theta2 = (int) map size in degrees (or arcmin if the keyword amin is set)}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{amin = (string) if set, the map size theta1 and theta2 are assumed to be in arcmin}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{sgamma = shear maps IDL structure with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\end{itemize}

%
%$\looparrowright$  \textbf{add\_gnoise\_gamma.pro} : Add a Gaussian noise to a shear maps structure :
%\index{add\_gnoise\_gamma.pro}
%\noindent Add a Gaussian noise to the shear maps depending on the number of galaxies per pixel.

%\begin{center}
% \textbf{USAGE : add\_gnoise\_gamma, sgamma, ng, s, sgamman}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{sgamma = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\item{ng = (int) galaxies number per arcmin square}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{s = (int) the root mean square of the noise}
%\item{sgamman = IDL structure of shear maps embedded in a gaussian noise with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) noisy shear maps $\gamma_{1b}$ and $\gamma_{2b}$}
%\end{itemize}

%
%$\looparrowright$  \textbf{gamma\_to\_kappa.pro} : Derive a mass map structure from a shear maps structure:
%\index{gamma\_to\_kappa.pro}
%\noindent Derive a mass map structure from shear maps structure using the relation \ref{eqn_reckE} in
%chapter \ref{ch_weak}.

%\begin{center}
% \textbf{USAGE : gamma\_to\_kappa, sgamma, smap}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{sgamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{cat = (string) if set, some fields (specific to real data) are added to the output mass map structure (ng, wtot, mask, gamma\_err, kappa\_err, ng\_eff, sigma\_gamma,x1\_ran, x2\_ran, x1\_m, x2\_m)}
%\item{bmode = (string) if set, the magnetic component of the mass map is computed, otherwise is the electric component that is computed}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}

%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%\textbf{if keyword\_set(cat) : }
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of  each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }
%\end{itemize}

%\subsection{IDL routines for real data}

%\vspace{0.3cm}

%$\blacktriangleright$   \textbf {Build a catalogue structure}

%\vspace{0.3cm}
%%$\twoheadrightarrow$
%$\looparrowright$ \textbf{mk\_gcat.pro} : Build a shear catalogue structure :
%\index{mk\_gcat.pro}
%\begin{center}
% \textbf{USAGE : mk\_gcat, x, y, pixscale, weight, g1, g2, gcat}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{x, y = (1D IDL array) coordinates in pixels of each galaxy}
%\item{pixscale = (int) pixel size [in rad]}
%\item{weight = (1D IDL array) weight of each galaxy}
%\item{g1, g2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{gcat = IDL structure of catalogue with the following fields : \\
%- x, y = (1D IDL array) coordinates in pixels of each galaxy\\
%- pixscale = (int) pixel size [in deg] \\
%- weight = (1D IDL array) weight of each galaxy \\
%- gamma1, gamma2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%$\blacktriangleright$   \textbf {Build a shear maps structure}

%\vspace{0.3cm}
%%$\twoheadrightarrow$
%$\looparrowright$ \textbf{gcat\_to\_gamma.pro} : Build a (pixelised) shear maps structure from a shear catalogue structure :
%\index{gcat\_to\_gamma.pro}
%\begin{center}
% \textbf{USAGE : gcat\_to\_gamma, gcat, gamma, delta=delta}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gcat = IDL structure of catalogue with the following fields : \\
%- x, y = (1D IDL array) galaxies position in pixels of each galaxy\\
%- pixscale = (int) pixel size [in rad] \\
%- weight = (1D IDL array) weight of each galaxy \\
%- gamma1, gamma2 = (1D IDL array) shear $\gamma_1$ and $\gamma_2$ of each galaxy}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{delta = (string) pixel size in $arcmin$, default is 1}
%\end{itemize}

%

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{gamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel \\
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }\\
%\end{itemize}

%
%\section{Relations between the distortion field and the projected (Electric) mass concentration}

%\vspace{0.3cm}

%\subsection{From shear maps $\gamma_1$, $\gamma_2$ to mass map $\kappa$}
%$\looparrowright$ \textbf{gamma\_to\_kappa.pro} : See description in previous subsection.\\
%\index{gamma\_to\_kappa.pro}

%\subsection{From mass map $\kappa$ to shear maps $\gamma_1$, $\gamma_2$}
%$\looparrowright$ \textbf{kappa\_to\_gamma.pro} : Derive a shear maps structure from a mass map structure using the relation \ref{eq_gamma} in chapter \ref{ch_weak}.

%\begin{center}
% \textbf{USAGE : kappa\_to\_gamma, smap, sgamma}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map $\kappa$}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{cat = (string) if set, some fields (specific to real data) are added to the output mass map structure (ng, wtot, mask, gamma\_err, kappa\_err, ng\_eff, sigma\_gamma,x1\_ran, x2\_ran, x1\_m, x2\_m)}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}

%\item{sgamma = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%\textbf{if keyword\_set(cat) : }
%\item{sgamma = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\ 
%(kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Electric and Magnetic mass maps}

%$\looparrowright$ \textbf{geb\_to\_ke\_kb.pro} : Compute the Electric and the Magnetic mass map from the shear maps :
%\index{geb\_to\_ke\_kb.pro}
%\noindent Perform a decomposition of the shear field into its 2 components : the Electric (E) component  and the Magnetic (B) one. The decomposition is based on a rotation of the shear by 45$^\circ$ to obtain the Magnetic component. The presence of B-modes is used to test the presence of systematic errors in Weak Lensing shear maps. Indeed, Weak Lensing only produces E-modes.

%\begin{center}
% \textbf{USAGE : geb\_to\_ke\_kb, gEB, mE, mB, cat= cat}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gEB = IDL structure of shear maps with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = IDL array of the mass map\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{cat = (string) if set, some fields (specific to real data) are added to the output mass map structure (ng, wtot, mask, gamma\_err, kappa\_err, ng\_eff, sigma\_gamma,x1\_ran, x2\_ran, x1\_m, x2\_m)}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mE= IDL structure of the magnetic component mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map with simulated missing data\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%\textbf{if keyword\_set(cat) : }
%\item{mE = IDL structure of the magnetic component mass map with the following fields: \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\
% (kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }

%

%\item{mB = IDL structure of the magnetic component mass map with the following fields: \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map with simulated missing data\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$}

%

%\textbf{if keyword\_set(cat) : }
%\item{mB = IDL structure of the magnetic component mass map with the following fields: \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight of each galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\
% (kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps per pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Missing data}

%\subsection{Add a hole in order to simulate missing data}

%$\looparrowright$ \textbf{add\_hole.pro} : Add a hole to the mass map :
%\index{add\_hole.pro}
%\noindent Add a square hole in the data (pixels are set to zero) to simulate missing data. To add more than one hole,  we can use the procedure in an iterative way, adding holes one by one. 

%\begin{center}
% \textbf{USAGE : add\_hole, smap, xh, yh, sh, mask,smaph}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = IDL array of the mass map}
%\item{xh, yh = (int) hole position (center)}
%\item{sh = (int) square size (half side)}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mask = (IDL array) mask to hide missing data in the mass map}
%\item{smaph = IDL structure of mass map with simulated missing data with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map with simulated missing data}
%\end{itemize}

%\subsection{How to overcome this problem?}
%$\looparrowright$ \textbf{whole.pro} : Compute the multi-resolution mask :
%\index{whole.pro}
%\noindent In some cases in multi-resolution filterings, a multiscale mask data mask can be required to remove all the impact of the missing data. All the pixels in the multi-resolution mask can be distorted by the presence of the hole or by the edge of the image.

%\begin{center}
% \textbf{USAGE : whole, mask, ny, wmask}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{mask = (IDL array) mask of the missing data in the mass map}
%\item{ny = (int) number of scales used in the wavelet transform}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{wmask = (3D IDL array) multi-resolution mask of the missing data in the mass map}
%\end{itemize}

%

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Filtering}
%\subsection{Gaussian Filtering}

%\vspace{0.3cm}

%
%$\looparrowright$ \textbf{rec\_kap\_gaus.pro} : Perform a Gaussian Filtering to filter a noisy mass map :
%\index{rec\_kap\_gaus.pro}
%\noindent Perform a Gaussian filtering by calculating the convolution between the noisy mass map and a gaussian window.

%\begin{center}
% \textbf{USAGE : rec\_kap\_gaus, map, sigma, mapg}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{map = IDL array of a noisy mass map }
%\item{sigma = (int) the width ($\sigma$) of the Gaussian window}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mapg = IDL array  of a filtered mass map by Gaussian filtering}
%\end{itemize}

%\subsection{Wiener Filtering}

%\vspace{0.3cm}

%
%$\looparrowright$ \textbf{rec\_kap\_wiener.pro} : Perform a Wiener Filtering to filter a noisy mass map :
%\index{rec\_kap\_wiener.pro}
%\noindent Perform a Wiener filtering (classical 1D method). Build the Wiener weight function by computing a weight for each ring (7) of the image.

%\begin{center}
% \textbf{USAGE : rec\_kap\_wiener, smap, sigmae, ng, mapw}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of a noisy mass map with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = IDL array of a noisy mass map}\\
%\item{sigmae = (int) shear error measurement (a common value is 0.3)}\\
%\item{ng = (int) number of galaxies per pixel (ng is equal to 20 $gal/amin^2$ for ground observations and 100 $gal/amin^2$ for space observations)}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mapw = IDL array  of a filtered mass map by Wiener filtering}
%\end{itemize}

%\subsection{Multiscale Entropy Filtering}

%\vspace{0.3cm}

%

%$\looparrowright$ \textbf{rec\_kap\_wl.pro} : Perform a Multiscale Entropy Filtering described in chapter \ref{ch:filter2} to filter a noisy mass map :
%\index{rec\_kap\_wl.pro}
%\noindent Apply the Multi-Resolution Filtering using the Multiscale Entropy concept and the False Discovery Rate (FDR) to derive robust detection levels in wavelet space.

%\begin{center}
% \textbf{USAGE : rec\_kap\_wl, map, mapwl, Opt='-n7 -k -I5 -C2 -c2. -s0.05 -F3 -K}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{map = (IDL array) noisy mass map}
%\end{itemize}

%
%\textbf{KEYWORDS} :\\
%      Opt: string which contains the different options. Options are:\\

%		[-n number\_of\_scales]\\
%               	\indent \indent Number of scales used in the multiresolution transform\\
%               	\indent \indent default is 4.\\

%		[-F first\_detection\_scale]\\
%		\indent \indent First scale used for the detection\\
%		\indent \indent default is 1.\\
%          
%		[-g sigma]\\
%		\indent \indent sigma = noise standard deviation assuming a Gaussian noise \\
%		\indent \indent by default, the standard deviation is automatically estimated. \\
% 					
%		[-k]\\
%             	\indent \indent Suppress isolated pixels in the support. Default is no.\\

%		[-K]\\
%             	\indent \indent Remove the smoothed plane. Default is no.\\

%		[-I NbIter]\\
%		\indent \indent Number of iterations in an iterative process of reconstruction\\
%		\indent \indent default is 10.\\

%		[-s NSigma]\\
%              	\indent \indent Thresolding at NSigma * SigmaNoise at each scale\\
%		\indent \indent default is 3.\\
%		\indent \indent FDR-Thresolding NSigma = $alpha_0$\\
%		\indent \indent default value is 0.05.\\

%
%		[-C Thresh\_Type]\\
%		\indent \indent Thresh\_Type = 1 : Use a NSigma * SigmaNoise thresholding\\
%		\indent \indent Thresh\_Type = 2 : Use a FDR Thresholding\\
%		\indent \indent default is 1.\\
%		
%          
%		[-c Alpha\_Variation]\\
%		\indent \indent If Thresh\_Type = 2, use a different alpha per band. \\
%		\indent \indent Choose a Alpha\_Variation value range between 1.7 and 2.

%		[-P]\\
%		\indent \indent Apply the positivity constraint\\
%		\indent \indent default is no.\\
%  
%		[-R RMS\_Map\_File\_Name]\\
%               	\indent \indent RMS Map \\

%		[-r]\\
%		\indent \indent rms map is automatically calculated\\

%		[-v]\\
%		\indent \indent Verbose. \\
%		\indent \indent default is no.\\

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mapwl = IDL array  of the filtered mass map by Multiscale Entropy filtering}
%\end{itemize}

%\textbf{EXTERNAL CALL} : 
%\begin{itemize}
%\item{wl\_t2\_filter (C++ program)}
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%\section{Tools}

%\subsection{Characterization}

%
%\vspace{0.3cm}

%$\blacktriangleright$   \textbf {Error per scale}

%$\looparrowright$ \textbf{run\_sigma.pro} : Compute an error per scale :
%Compute the error between the original mass map and the filtered one for each scale taking into account the edges.
%\index{run\_sigma.pro}
%\begin{center}
%\textbf{USAGE : run\_sigma, w, ny, wn, sigma\_n}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{w = (3D IDL array) wavelet transform of the original image}
%\item{ny = (int) number of scales used in the wavelet transform}
%\item{wn = (3D IDL array) wavelet transform of the filtered image}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{sigma\_n= error per scale}
%\end{itemize}

%$\looparrowright$ \textbf{run\_sigma\_hole.pro} : Compute an error per scale for a map with missing data :
%Compute the error between the original mass map and the filtered one for each scale taking into account the edges and the missing data.
%\index{run\_sigma\_hole.pro}

%\begin{center}
% \textbf{USAGE : run\_sigma\_hole, wmask, w, ny, wn, sigma\_n}
%\end{center}

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{wmask = (3D IDL array) multi-resolution hole mask}
%\item{w = (3D IDL array) wavelet transform of the original image}
%\item{ny = (int) number of scales used in the wavelet transform}
%\item{wn = (3D IDL array) wavelet transform of the filtered image}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{sigma\_n= error per scale}
%\end{itemize}

%$\blacktriangleright$   \textbf {Cluster detection}

%Another important aspect of the weak shear mass reconstruction is the possibility 
%to detect clusters and to build a catalog. Thanks to isophote map overplotted on the true mass map as contours, we can check visually the false detections.
%\vspace{0.3cm}

%
%$\looparrowright$ \textbf{isophot\_gaus\_rms.pro} : Compute an isophote map for Gaussian filtering : In the Gaussian isophote maps, the isophotes corresponds to a $k\sigma$ detection level where k = 3, 4, 5.
%\index{isophot\_gaus\_rms.pro}
%\begin{center}
%\textbf{USAGE : isophot\_gaus\_rms, map, sigma, rms\_map, mapg, isog}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{map = IDL array of a noisy mass map}
%\item{sigma = (int) the width ($\sigma$) of the Gaussian window}
%\item{rms\_map = (IDL array) rms map, if $rms = cte$ map of constant value}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mapg = IDL array  of a filtered mass map by Gaussian filtering}
%\item{isog = (IDL array)  isophote map for Gaussian filtering}
%\end{itemize}

%
%$\looparrowright$ \textbf{isophot\_wiener\_rms.pro} : Compute an isophote map for Wiener filtering :
% In the Wiener isophote maps, the isophotes corresponds to a $k\sigma$ detection level where k = 3, 4, 5.
%\index{isophot\_wiener\_rms.pro}

%\begin{center}
%\textbf{USAGE : isophot\_wiener\_rms, smap, rms\_map, sigmae, ng, mapw, isow}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of a noisy mass map}
%\item{rms\_map = (IDL array) rms map, if $rms = cte$ map of constant value}
%\item{sigmae = (int) measurement error in $\gamma_{i,j}$ per pixel}
%\item{ng= (int) number of galaxies per pixel}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{mapw = IDL array  of a filtered mass map by Wiener filtering}
%\item{isow = (IDL array)  isophote map for Wiener filtering}
%\end{itemize}

%$\looparrowright$ \textbf{isophot\_fdrl.pro} : Compute an isophote map for Multiscale Entropy filtering :
% Using the FDR-thresholding in wavelet space, we detect as significant a set of wavelet coefficients. Then, we built an isophote map, where each isophote level corresponds to the detection level in a given scale. A cluster surrounded by two isophotes means that it has been 
%detected at two scales.
%\index{isophot\_fdrl.pro}
%\begin{center}
%\textbf{USAGE : isophot\_fdrl,  smap, ny, ground=ground, space = space, min\_scale, iso\_fdr}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of a noisy mass map}
%\item{ny = (int) number of scales used in the wavelet transform}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{ground = (string) if set, we compute the fdr-threshold for ground observations}
%\item{space = (string) if set, we compute the fdr-threshold for space observations}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{min\_scale = (IDL array)  map with the minimum scale of detection for each pixel }
%\item{iso\_fdr = (IDL array)  isophote map with the maximum detection for each pixel for Multiscale Entropy filtering}
%\end{itemize}

%\subsection{Plots}

%\vspace{0.3cm}

%$\blacktriangleright$   \textbf {Plot the shear map}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{plt\_shear.pro} : Plot a shear map from a mass map or shear maps.
%Overplot the shear on the corresponding mass map.
%\index{plt\_shear.pro}
%\begin{center}
%\textbf{USAGE : plt\_shear, smap, kappa = kappa, gamma = gamma}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of a mass map or shear maps}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{kappa = (string) is set if mass map input}
%\item{gamma = (string) is set if shear maps input}
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{overplot the shear field over the mass map}
%\end{itemize}

%$\blacktriangleright$   \textbf {Plot galaxies position from a shear catalogue}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{plt\_xy\_gcat.pro} : Plot for each galaxy of the catalogue a cross to give the position.
%\index{plt\_xy\_gcat.pro}
%\begin{center}
%\textbf{USAGE : plt\_xy\_gcat, gcat}
%\end{center}

%

%\textbf{INPUTS} : 
%\begin{itemize}
%\item{gcat = IDL structure of a shear catalogue with the following fields : \\
%- x, y = (IDL array) coordinates in pixel of each galaxy\\
%- gamma1, gamma2 = (IDL array) shear maps $\gamma_1$ and $\gamma_2$\\
%- pixscale = (int) pixel size [rad]}\\
%\end{itemize}

%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{plot the galaxies position of the catalogue}
%\end{itemize}

%$\blacktriangleright$   \textbf {Plot a mass map field (specific to real data)}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{plt\_kappa.pro} : Plot the mass map field using the real dimensions [in rad] and overplot the snr contours.
%\index{plt\_kappa.pro}
%\begin{center}
%\textbf{USAGE : plt\_kappa, smap, contours = contours}
%\end{center}

%
%\textbf{INPUTS} : 
%\begin{itemize}
%\item{smap = IDL structure of a mass map  with the following fields : \\
%- n1, n2 = (int) map size in pixels\\
%- theta1, theta2 = (int) map size in radians\\
%- delta1, delta2 = (int) pixel size in radians\\
%- kappa = (IDL array) mass map\\
%- gamma1, gamma2 = (IDL array) shear maps\\
%- ng = (IDL array) number of galaxies per pixel\\
%- wtot = (IDL array) weight per pixel\\
%- mask = (IDL array) mask of the missing data\\
%- gamma\_err = (IDL array) measurement error in shear maps per pixel taking into account the weight per galaxy\\
%- kappa\_err = (IDL array) measurement error in mass map per pixel\\
% (kappa\_err=gamma\_err/sqrt(2.))\\
%- ng\_eff = (IDL array) effective number of galaxies per pixel taking into account the weight of each galaxy\\
%- sigma\_gamma = (int) measurement error in shear maps of each pixel\\
%- x1\_ran, x2\_ran = (int) exact range in degree\\
%- x1\_m, x2\_m = IDL array with the exact middle position (in deg) of each pixel }\\
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{contours = (string) if set we overplot the snr contours}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{plot the $\kappa$ field using the real dimensions and overplot the snr contours (if contours is set)}\\
%\end{itemize}

%
%$\blacktriangleright$   \textbf {Plot an image scaled to the current window}

%\vspace{0.3cm}

%$\looparrowright$ \textbf{plt\_image.pro} : Plot an image scaled to the current window. Further plotting (such as contours) can be performed over the resulting plot. Optionally, an annotated color bar can be drawn at the top. The 'scalable' keyword must be invoked when outputing to a postscript file.
%\index{plt\_image.pro}

%
%\begin{center}
%\textbf{USAGE : plt\_image, map, frame = frame, colbar=colbar, cran=cran, title=title, xtitle=xtitle, ytitle=ytitle, ctitle=ctitle, inverse=inverse, scalable=scalable, csize=csize}
%\end{center}

%
%\textbf{INPUTS} : 
%\begin{itemize}
%\item{map = (IDL array) an image}
%\end{itemize}

%\textbf{KEYWORD} :
% \begin{itemize}
%\item{frame = (string) if set, draw a frame with pixel index limits}
%\item{colbar = (string) if set, draw color bar}
%\item{cran = (string) change the range  (default: [min(map),max(map)])}
%\item{title = (string) set a title for the plot}
%\item{x,ytitle = (string) set titles for the frame}
%\item{ctitle = (string) set a title for the colorbar}
%\item{inverse = (string) if set, invert the color coding}
%\item{scalable = (string) if set, use scalable pixels which is to be ps devices 
%(default: nonscalable to be used with x-term device)}
%\item{csize = (string) vertical size of the color bar (0-1, default:.12)}
%\end{itemize}

%
%\textbf{OUTPUTS} : 
%\begin{itemize}
%\item{plot of the scaled image with, optionally, a coordinate frame and a color bar.}
%\end{itemize}

%\section{Conclusion}

%We have now at your disposal all the tools to process Weak Lensing data. In the flowchart in Fig.\ref{organigramme}, the different areas stand for the different main processings. All the routines write down in this flowchart are described in the IDL routines section.\\

%\begin{figure}[htp!]
%\begin{center}
%\includegraphics[scale=0.7]{organigramme.ps}
%\caption{software MRL flowchart}
%\label{organigramme}
%\end{center}
%\end{figure}

% In the yellow area, we have the specific routines to simulated data and in the green area, we have the ones that are specific to real data. The red area is dedicated to the building of the Electric and Magnetic mass map. The white area stands for the relation and the inverse relation between the mass map and the shear maps. Finally the blue area represents the filtering step (Gaussian filtering, Wiener Filtering, Multiscale Entropy Filtering).  Optionally, we can add a characterization step.\\

%Depending on the kind of data at your disposal, one can take a different path in the flowchart. And then you run one by one the different routines.

%\end{document}